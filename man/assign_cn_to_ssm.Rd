% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assign_cn_to_ssm.R
\name{assign_cn_to_ssm}
\alias{assign_cn_to_ssm}
\title{Assign CN to SSM.}
\usage{
assign_cn_to_ssm(
  these_samples_metadata,
  maf_data,
  seg_data,
  projection,
  coding_only = FALSE,
  assume_diploid = FALSE,
  include_silent = FALSE,
  ...
)
}
\arguments{
\item{these_samples_metadata}{Metadata table with one or more rows to specify
the samples to process.}

\item{maf_data}{A data frame of mutations in MAF format or maf_data object
(e.g. from \code{get_coding_ssm} or \code{get_ssm_by_sample}).}

\item{seg_data}{A data frame of segmented copy number data or seg_data object}

\item{projection}{Specified genome projection that returned data is relative to.
This is only required when it cannot be inferred from maf_df or seg_df
(or they are not provided).}

\item{coding_only}{Optional. Set to TRUE to restrict to only variants in coding space
Default is to work with genome-wide variants.}

\item{assume_diploid}{Optional, this parameter annotates every mutation as
copy neutral. Default is FALSE.}

\item{include_silent}{Logical parameter indicating whether to include silent
mutations in coding space. Default is FALSE. This parameter only
makes sense if \code{coding_only} is set to TRUE.}

\item{...}{Any additional parameters.}
}
\value{
A list containing a data frame (MAF-like format) with three extra
columns:
- log.ratio is the log ratio from the seg file (NA when no overlap).
- LOH
- CN (the rounded absolute copy number estimate of the region based on
log.ratio, NA when no overlap was found).
}
\description{
Annotate mutations with their copy number information.
}
\details{
This function takes a metadata table and returns all mutations
for the samples in that metadata. Each mutation is annotated with the
local copy number state of each mutated site. The user can specify if
only coding mutations are of interest. To do so,
set \code{coding_only = TRUE}. When necessary, this function relies on
\code{get_ssm_by_samples} and \code{get_cn_segments} to obtain the required data.
}
\examples{
# long-handed way
# 1. get some metadata for a collection of samples
some_meta = get_gambl_metadata() \%>\%
        dplyr::filter(cohort=="FL_Dreval",
        grepl("SP",sample_id))
# 2. Get the SSMs for these samples

ssm_genomes_grch37 = get_coding_ssm(projection = "grch37",
                                  these_samples_metadata = some_meta)
# peek at the results
ssm_genomes_grch37 \%>\% dplyr::select(1:8)

# 3. Lazily let this function obtain the corresponding seg_data for the right genome_build
cn_list = assign_cn_to_ssm(some_meta,ssm_genomes_grch37)

cn_list$maf \%>\% dplyr::select(1:8,log.ratio,CN)

# This won't work because the hg38 seg_data is not bundled
ssm_genomes_hg38 = get_coding_ssm(projection = "hg38",
                                  these_samples_metadata = some_meta)
cn_list = assign_cn_to_ssm(some_meta,ssm_genomes_hg38)

# Easiest/laziest way:
cn_list = assign_cn_to_ssm(projection = "grch37")


cn_list$maf \%>\% dplyr::group_by(Tumor_Sample_Barcode,CN) \%>\%
  dplyr::count()

}
