[
  {
    "objectID": "resources/functions.html",
    "href": "resources/functions.html",
    "title": "Functions overview",
    "section": "",
    "text": "The GAMBLR.data package not only stores data, but also provides some basic functionality to easily retrieve and operate on this data. Almost all of the functions listed below are the “lighter” version of those in the associated package GAMBLR.results, which means that the functions included here do not require you to be Morin Lab member or have access to GSC.\nThere is a limited number of basic functions available, therefore the functions are not separated into categories below. Nevertheless, these are the basic functions available:\n\nannotate_hotspots: Annotate maf data with hotspots. Will return the same maf as input with an additional logical column showing whether the particular SSM is in the hotspot region.\nassign_cn_to_ssm: Annotate maf data by assigning copy number state to SSM. Will return the same maf as input with an additional column showing the absolute copy number state of the variant in that position.\ncalc_mutation_frequency_bin_region: Calculate mutation frequency by sliding window. Will return a numeric matrix with rows corresponding to samples and values showing number of mutations in the given window. Operates only on one given region. If you need to analyze many regions, use the plural version of this function.\ncalc_mutation_frequency_bin_regions: Calculate mutation frequency by sliding window. Will return a numeric matrix with rows corresponding to samples and values showing number of mutations in the given window. This function is really just a wrapper for the singular version but works on many given regions.\ncheck_excess_params: Helper function that ensures arguments given to the functions in this package are appropriate, and will drop any unsupported arguments.\ncollate_results: This currently adds the QC metrics to the given set of samples in the metadata.\nget_ashm_count_matrix: Returns a matrix showing how many mutations are in the given aSHM region for each given sample.\nget_cn_segments: Returns copy number data in seg format in a given region.\nget_coding_ssm: Returns maf data with only coding mutations.\nget_coding_ssm_status: Returns a binary matrix showing whether or not each given sample is mutated in each given gene.\nget_gambl_metadata: Returns metadata for the whole collection of samples present in GAMBL.\nget_manta_sv: Returns SV calls from manta.\nget_sample_cn_segments: Returns the CNV data for a given sample in seg format.\nget_ssm_by_patients: Returns maf data (both coding and non-coding mutations) for a given set of patients. This will return maf data for multiple samples if they exist for a given patient.\nget_ssm_by_regions: Returns maf data of the variants in the given regions.\nget_ssm_by_samples: Returns maf data (both coding and non-coding mutations) for a given set of samples. This will return maf data for only the specified samples even if multiple samples exist for a given patient.\nid_ease: Internal function that converts a vector of sample ids into a data frame with metadata and vice versa. Used internally and is not really meant for standalone use.\nprocess_regions: Helper function that will harmonize genomic regions specified as character vectors or a data frame. Returns a list with two objects: regions as a vector and regions in bed format.\nregion_to_chunks: Helper function that will separate a chromosome region specified in UCSC format (chr:start-end) into individual chunks of chromosome, start, and end.\nreview_hotspots Review hotspot mutations at certain genes to ensure they are correctly annotated. For example, will mark any missence mutation within KAT domain of CREBBP as hotspot. Only selected genes are supported.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "concepts/GAMBLR_family.html",
    "href": "concepts/GAMBLR_family.html",
    "title": "GAMBLR family of packages",
    "section": "",
    "text": "GAMBLR.data is the first and most basic member of the GAMBLR family of packages. It mostly serves the purpose of storing the bundled data helpful for genomic analysis of B-cell neoplasms in R, but also contains small basic functions serving as API to retrieve this data.\nSome of the bundled data is versioned as it is continuously being updated. This includes, but is not limited to, regions targeted by aSHM (new regions are being added as they are identified), the curated list of lymphoma genes, somatic mutation hotspots, etc. Conveniently for the user, unless they request the specific version of the data, the most recent and up-to-date version is used by default.\nThe GAMBLR family includes:\n\nGAMBLR.data - this package\nGAMBLR.helpers - a set of low-level functions for data operation\nGAMBLR.utils - higher level set of functions to operate on genomic data\nGAMBLR.viz - set of functions used mostly for visualizations\nGAMBLR.results - used to access the full data in GAMBL project. Only available for members of the Morin Lab and requires access to GSC, but can also be run locally once properly configured and synced.\n\nThis diagram illustrates in a simplified way the dependency relationship of different packages in the GAMBLR.family:\n\n\n\n\nflowchart LR\n  A(\"GAMBLR.data\") --&gt; B(\"GAMBLR.helpers\")\n  B --&gt; C(\"GAMBLR.utils\")\n  C --&gt; D(\"GAMBLR.viz\")\n  D --&gt; E{\"Morin Lab member?\"}\n  E -- YES --&gt; F(\"GAMBLR.results\")\n  E -- NO --&gt; A\n\n\n\n\n\nAll dependencies should be installed automatically for you, just like with any other R package. If not, please report the issue in the appropriate GitHub repo.\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html",
    "href": "tutorials/assemble_feature_matrix.html",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "In 2023, the Morin Lab developed a classifier of Follicular Lymphoma (FL) predictive of histological transformation to more aggressive DLBCL. This study was published in Blood (2023). How was the binary feature matrix assembled for that machine learning model?\nIn this quick tour we will show how GAMBLR.data resources can help you to generate such matrix.\n\n# Load packages\nlibrary(GAMBLR.data)\nlibrary(tidyverse)\n\nThis tutorial explores how to obtain metadata for the samples, simple somatic mutations in maf format, and auto-magically transform it into a binary matrix of features. To simplify this tutorial, we will only include a small subset of features (not the whole set as was used in the original paper), but this example will be able to illustrate the functionality and highlight the main steps of the process.\n\n\nIn the previous tutorial, we have already explored the function get_gambl_metadata(). In contrast, here we will use different approach as the metadata from the Supplemental Table 1 is direcly available in the object sample_data. Let’s retreive it:\n\nmetadata &lt;- sample_data$meta\n\nNow that we have the metadata, we can look at the available columns and find samples from the FL study:\n\n# What are columns available?\ncolnames(metadata)\n\n [1] \"patient_id\"           \"sample_id\"            \"Tumor_Sample_Barcode\"\n [4] \"seq_type\"             \"sex\"                  \"COO_consensus\"       \n [7] \"lymphgen\"             \"genetic_subgroup\"     \"EBV_status_inf\"      \n[10] \"cohort\"               \"pathology\"            \"reference_PMID\"      \n[13] \"genome_build\"         \"pairing_status\"       \"age_group\"           \n[16] \"compression\"          \"bam_available\"        \"pathology_rank\"      \n[19] \"DHITsig_consensus\"    \"ffpe_or_frozen\"       \"fl_grade\"            \n[22] \"hiv_status\"           \"lymphgen_cnv_noA53\"   \"lymphgen_no_cnv\"     \n[25] \"lymphgen_with_cnv\"    \"lymphgen_wright\"      \"molecular_BL\"        \n[28] \"normal_sample_id\"     \"time_point\"          \n\n# How can I find samples from the FL study?\ntable(metadata$cohort)\n\n\n       BL_Thomas     DLBCL_Arthur DLBCL_cell_lines     dlbcl_chapuy \n             234              153                5              233 \n    DLBCL_Hilton      dlbcl_reddy    dlbcl_schmitz     DLBCL_Thomas \n             160              999              470               43 \n       FL_Dreval \n             443 \n\n\nWe can now see that the samples from the FL study are in the cohort FL_Dreval. Let’s explore these samples more:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(cohort == \"FL_Dreval\")\n\ntable(metadata$pathology)\n\n\nCOMFL DLBCL    FL \n   21   209   213 \n\n\nNow, let’s take 10 samples from the FL study: 5 FL and 5 DLBCL:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(pathology %in% c(\"FL\", \"DLBCL\")) %&gt;%\n    group_by(pathology) %&gt;%\n    arrange(sample_id) %&gt;%\n    slice_tail(n = 5) %&gt;%\n    ungroup\n\n# How does our metadata looks like now?\nstr(metadata)\n\ntibble [10 × 29] (S3: tbl_df/tbl/data.frame)\n $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...\n $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...\n $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...\n $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...\n $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...\n $ EBV_status_inf      : chr [1:10] NA NA NA NA ...\n $ cohort              : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...\n $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...\n $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...\n $ genome_build        : chr [1:10] NA NA NA NA ...\n $ pairing_status      : chr [1:10] NA NA NA NA ...\n $ age_group           : chr [1:10] NA NA NA NA ...\n $ compression         : chr [1:10] NA NA NA NA ...\n $ bam_available       : logi [1:10] NA NA NA NA NA NA ...\n $ pathology_rank      : num [1:10] NA NA NA NA NA NA NA NA NA NA\n $ DHITsig_consensus   : chr [1:10] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:10] NA NA NA NA ...\n $ fl_grade            : chr [1:10] NA NA NA NA ...\n $ hiv_status          : chr [1:10] NA NA NA NA ...\n $ lymphgen_cnv_noA53  : chr [1:10] NA NA NA NA ...\n $ lymphgen_no_cnv     : chr [1:10] NA NA NA NA ...\n $ lymphgen_with_cnv   : chr [1:10] NA NA NA NA ...\n $ lymphgen_wright     : chr [1:10] NA NA NA NA ...\n $ molecular_BL        : chr [1:10] NA NA NA NA ...\n $ normal_sample_id    : chr [1:10] NA NA NA NA ...\n $ time_point          : chr [1:10] NA NA NA NA ...\n\n\nOur subsetting worked and we can now proceed with matrix assembly.\n\n\n\nWe will now use the metadata from the previous step to assemble the binary feature matrix.\n\n\nFirst, lets return the data frame with simple somatic mutations in maf format and store it in a variable. Technically this step is not strictly necessary, as each function used below will be able to retreive it for you when the maf data is not provided, but we will advocate for good practice here and have the maf data stored in a designated variable. As we will be utilizing both coding and non-coding mutations, we will take advantage of returning the variants per sample (without necessarily restricting to coding-only variants).\n\n# Obtain simple somatic mutations\nmaf &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata\n)\n\nWow, that was super easy and blazing fast! Did it even work?? Let’s confirm:\n\n# How many samples are present in maf?\nlength(unique(maf$Tumor_Sample_Barcode))\n\n[1] 10\n\n# Are all these samples the ones we are interested in and requested with metadata?\nsort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# What are the mutations in the maf? Are they just coding?\ntable(maf$Variant_Classification)\n\n\n               3'Flank                  3'UTR                5'Flank \n                    29                     20                    127 \n                 5'UTR        Frame_Shift_Del        Frame_Shift_Ins \n                    61                      7                      1 \n                   IGR           In_Frame_Del                 Intron \n                    46                      2                   1502 \n     Missense_Mutation      Nonsense_Mutation                    RNA \n                    78                      9                     15 \n                Silent          Splice_Region            Splice_Site \n                    29                      6                      8 \nTranslation_Start_Site \n                     1 \n\n\nWe can see from the above outputs that we got somatic mutations for all requested samples and the maf contains both coding and non-coding variants. We can now proceed to the next steps.\n\n\n\nThe feature matrix in the FL study contained coding mutation status at selected genes denoted as 1 when the mutation was present and 0 when there was no mutation. In addition to that, mutation hotspots at some genes were also taken into account. To complicate things more, annotation of hotspots was performed differently depending on the specific gene and mutational effect. Specifically, the CREBBP missemse mutations were considered hotspots when they occured in the KAT domain, but not outside of it. The mutations in FOXO1 were considered hotspots when the AA change was at M1. GAMBLR.data provides a one-stop shop to achieve this level of details out-of-the-box in a simple and convenient way with get_coding_ssm_status functions. It has a logical arguments include_hotspots to separate regular mutations from the ones occurring at hotspots, and review_hotspots, which will handle the specific cases we described above in an automated way. Both of these arguments are TRUE by default, so you do not need to toggle them separately, but in this exaple we will specify them explicitly just to illustrate that this will happen during the function call. To keep the example clean and concise, we will also annotate the mutation status only for a few of selected genes.\n\n# Specify genes to annotate\nour_genes &lt;- c(\n    \"CREBBP\", \"MYD88\", \"RRAGC\",\n    \"PIM1\", \"BCL2\", \"BCL6\"\n)\n\n# Generate binary matrix\ncoding_matrix &lt;- get_coding_ssm_status(\n    gene_symbols = our_genes,\n    these_samples_metadata = metadata,\n    maf_data = maf,\n    include_hotspots = TRUE,\n    review_hotspots = TRUE\n)\n\ncoding_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n\n\nWe can see that in this example there is only one sample with hotspot mutation in CREBBP, SP59424 (annotated as 1 in the column CREBBPHOTSPOT). Let’s sanity check this annotation for illustration purposes:\n\ncrebbp_hotspot_mutation &lt;- maf %&gt;%\n    filter(\n        Tumor_Sample_Barcode == \"SP59424\",\n        Hugo_Symbol == \"CREBBP\"\n    ) %&gt;%\n    select(Chromosome, Start_Position, Variant_Classification)\n\ncrebbp_hotspot_mutation\n\n   Chromosome Start_Position Variant_Classification\n1:         16        3788650      Missense_Mutation\n\n\nThis mutation falls within KAT domain and is a missense variant, so it is indeed correct to be annotated as hotspot. How can we check it does fall within KAT domain? It is easy with GAMBLR.data:\n\n# GAMBLR.data has the regions to be considered as hotspots\nhotspot_regions_grch37\n\n               chrom     start       end\nCREBBP            16   3785000   3791000\nEZH2               7 148508764 148506238\nNOTCH1             9 139391455 139391455\nNOTCH2             1 120459150 120459150\nCD79B_trunc       17  62007172  62007172\nCD79B_NONtrunc    17  62006800  62006800\n\n# Now check that CREBBP mutations\nbetween(\n    crebbp_hotspot_mutation$Start_Position,\n    hotspot_regions_grch37[\"CREBBP\", \"start\"],\n    hotspot_regions_grch37[\"CREBBP\", \"end\"]\n)\n\n[1] TRUE\n\n\nWe have now generated matrix of coding mutations and SSM hotspots in a binary format and are ready to proceed to the next step.\n\n\n\nThe FL study also annotated the non-coding mutations at selected aSHM targets as features of binary matrix. Again, all the necessarily means to do it in a simple step are provided by GAMBLR.data. The regions targeted by aSHM are available in the GAMBLR.data. Since they are always complemented with new regions once they are identified, the latest and most comprehensive version is always available by referring to {projection}_ashm_regions. However, this use case is a perfect exmple to demonstarate how to operate on versioned iterations of the aSHM target list, as the list has been updated since the time the study was published and at the time of publication version 0.2 was used. We can refer to it directly by the version number:\n\nregions_bed &lt;- somatic_hypermutation_locations_GRCh37_v0.2\n\nhead(regions_bed)\n\n  chr_name hg19_start  hg19_end    gene     region regulatory_comment\n1     chr2   96808901  96811913   DUSP2   intron-1           enhancer\n2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer\n3    chr11  128339774 128345731    ETS1    introns           enhancer\n4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter\n5     chr6   31548325  31550717     LTB   intron-1           enhancer\n6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter\n\n\nWe will perform some simple modifications to it to make our experience better and only select few regions for illustrative purposes:\n\nour_regions &lt;- c(\n    \"BCL6-TSS\",\n    \"BCL7A-TSS\",\n    \"RHOH-TSS\",\n    \"ZFP36L1-TSS\"\n)\n\nregions_bed &lt;- regions_bed %&gt;%\n    mutate(\n        name = paste(gene, region, sep = \"-\")\n    ) %&gt;%\n    filter(\n        name %in% our_regions\n    )\n\nregions_bed\n\n  chr_name hg19_start  hg19_end    gene region regulatory_comment        name\n1     chr3  187458526 187464632    BCL6    TSS               &lt;NA&gt;    BCL6-TSS\n2    chr12  122456912 122464036   BCL7A    TSS    poised_promoter   BCL7A-TSS\n3    chr14   69257848  69259739 ZFP36L1    TSS    active_promoter ZFP36L1-TSS\n4     chr4   40193105  40204231    RHOH    TSS    active_promoter    RHOH-TSS\n\n\nNow we can see whether or not there are any mutations within these regions:\n\nashm_matrix &lt;- get_ashm_count_matrix(\n    regions_bed = regions_bed,\n    maf_data = maf,\n    these_samples_metadata = metadata\n)\n\nashm_matrix\n\n        BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\nSP59412        4           1         0        0\nSP59448        6           4        14        3\nSP59452       18           2        12       28\nSP59456        2           6         0        9\nSP59460        1           1         1        2\nSP59420        1           0         1        0\nSP59424        0           0         0        1\nSP59432        0           0         0        0\nSP59436        1           0         0        0\nSP59464        1           0         0        0\n\n\nWe how calculated the number of mutations in each region for each sample. The original study used pathology-specific values per region to convert these counts to binary, but here we will use a cutoff of 5 to binarize these counts. We will also convert rownames to column so it will be easier for us to unite all matrices into single one at the later steps:\n\nashm_matrix[ashm_matrix &lt;= 5] = 0\nashm_matrix[ashm_matrix &gt; 5] = 1\nashm_matrix &lt;- ashm_matrix %&gt;%\n    rownames_to_column(\"sample_id\")\n\nashm_matrix\n\n   sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1    SP59412        0           0         0        0\n2    SP59448        1           0         1        0\n3    SP59452        1           0         1        1\n4    SP59456        0           1         0        1\n5    SP59460        0           0         0        0\n6    SP59420        0           0         0        0\n7    SP59424        0           0         0        0\n8    SP59432        0           0         0        0\n9    SP59436        0           0         0        0\n10   SP59464        0           0         0        0\n\n\nWe have now generated matrix of non-coding mutations in a binary format and are ready to unite all matrices together.\n\n\n\nWe can now combine both coding and non-coding mutations into single matrix:\n\nfeature_matrix &lt;- left_join(\n    coding_matrix,\n    ashm_matrix\n)\n\nfeature_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n   BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1         0           0         0        0\n2         1           0         1        0\n3         1           0         1        1\n4         0           1         0        1\n5         0           0         0        0\n6         0           0         0        0\n7         0           0         0        0\n8         0           0         0        0\n9         0           0         0        0\n10        0           0         0        0\n\n\nThat’s it!\nHappy GAMBLing!"
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html#obtain-metadata",
    "href": "tutorials/assemble_feature_matrix.html#obtain-metadata",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "In the previous tutorial, we have already explored the function get_gambl_metadata(). In contrast, here we will use different approach as the metadata from the Supplemental Table 1 is direcly available in the object sample_data. Let’s retreive it:\n\nmetadata &lt;- sample_data$meta\n\nNow that we have the metadata, we can look at the available columns and find samples from the FL study:\n\n# What are columns available?\ncolnames(metadata)\n\n [1] \"patient_id\"           \"sample_id\"            \"Tumor_Sample_Barcode\"\n [4] \"seq_type\"             \"sex\"                  \"COO_consensus\"       \n [7] \"lymphgen\"             \"genetic_subgroup\"     \"EBV_status_inf\"      \n[10] \"cohort\"               \"pathology\"            \"reference_PMID\"      \n[13] \"genome_build\"         \"pairing_status\"       \"age_group\"           \n[16] \"compression\"          \"bam_available\"        \"pathology_rank\"      \n[19] \"DHITsig_consensus\"    \"ffpe_or_frozen\"       \"fl_grade\"            \n[22] \"hiv_status\"           \"lymphgen_cnv_noA53\"   \"lymphgen_no_cnv\"     \n[25] \"lymphgen_with_cnv\"    \"lymphgen_wright\"      \"molecular_BL\"        \n[28] \"normal_sample_id\"     \"time_point\"          \n\n# How can I find samples from the FL study?\ntable(metadata$cohort)\n\n\n       BL_Thomas     DLBCL_Arthur DLBCL_cell_lines     dlbcl_chapuy \n             234              153                5              233 \n    DLBCL_Hilton      dlbcl_reddy    dlbcl_schmitz     DLBCL_Thomas \n             160              999              470               43 \n       FL_Dreval \n             443 \n\n\nWe can now see that the samples from the FL study are in the cohort FL_Dreval. Let’s explore these samples more:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(cohort == \"FL_Dreval\")\n\ntable(metadata$pathology)\n\n\nCOMFL DLBCL    FL \n   21   209   213 \n\n\nNow, let’s take 10 samples from the FL study: 5 FL and 5 DLBCL:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(pathology %in% c(\"FL\", \"DLBCL\")) %&gt;%\n    group_by(pathology) %&gt;%\n    arrange(sample_id) %&gt;%\n    slice_tail(n = 5) %&gt;%\n    ungroup\n\n# How does our metadata looks like now?\nstr(metadata)\n\ntibble [10 × 29] (S3: tbl_df/tbl/data.frame)\n $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...\n $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...\n $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...\n $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...\n $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...\n $ EBV_status_inf      : chr [1:10] NA NA NA NA ...\n $ cohort              : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...\n $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...\n $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...\n $ genome_build        : chr [1:10] NA NA NA NA ...\n $ pairing_status      : chr [1:10] NA NA NA NA ...\n $ age_group           : chr [1:10] NA NA NA NA ...\n $ compression         : chr [1:10] NA NA NA NA ...\n $ bam_available       : logi [1:10] NA NA NA NA NA NA ...\n $ pathology_rank      : num [1:10] NA NA NA NA NA NA NA NA NA NA\n $ DHITsig_consensus   : chr [1:10] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:10] NA NA NA NA ...\n $ fl_grade            : chr [1:10] NA NA NA NA ...\n $ hiv_status          : chr [1:10] NA NA NA NA ...\n $ lymphgen_cnv_noA53  : chr [1:10] NA NA NA NA ...\n $ lymphgen_no_cnv     : chr [1:10] NA NA NA NA ...\n $ lymphgen_with_cnv   : chr [1:10] NA NA NA NA ...\n $ lymphgen_wright     : chr [1:10] NA NA NA NA ...\n $ molecular_BL        : chr [1:10] NA NA NA NA ...\n $ normal_sample_id    : chr [1:10] NA NA NA NA ...\n $ time_point          : chr [1:10] NA NA NA NA ...\n\n\nOur subsetting worked and we can now proceed with matrix assembly."
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html#generate-feature-matrix",
    "href": "tutorials/assemble_feature_matrix.html#generate-feature-matrix",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "We will now use the metadata from the previous step to assemble the binary feature matrix.\n\n\nFirst, lets return the data frame with simple somatic mutations in maf format and store it in a variable. Technically this step is not strictly necessary, as each function used below will be able to retreive it for you when the maf data is not provided, but we will advocate for good practice here and have the maf data stored in a designated variable. As we will be utilizing both coding and non-coding mutations, we will take advantage of returning the variants per sample (without necessarily restricting to coding-only variants).\n\n# Obtain simple somatic mutations\nmaf &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata\n)\n\nWow, that was super easy and blazing fast! Did it even work?? Let’s confirm:\n\n# How many samples are present in maf?\nlength(unique(maf$Tumor_Sample_Barcode))\n\n[1] 10\n\n# Are all these samples the ones we are interested in and requested with metadata?\nsort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# What are the mutations in the maf? Are they just coding?\ntable(maf$Variant_Classification)\n\n\n               3'Flank                  3'UTR                5'Flank \n                    29                     20                    127 \n                 5'UTR        Frame_Shift_Del        Frame_Shift_Ins \n                    61                      7                      1 \n                   IGR           In_Frame_Del                 Intron \n                    46                      2                   1502 \n     Missense_Mutation      Nonsense_Mutation                    RNA \n                    78                      9                     15 \n                Silent          Splice_Region            Splice_Site \n                    29                      6                      8 \nTranslation_Start_Site \n                     1 \n\n\nWe can see from the above outputs that we got somatic mutations for all requested samples and the maf contains both coding and non-coding variants. We can now proceed to the next steps.\n\n\n\nThe feature matrix in the FL study contained coding mutation status at selected genes denoted as 1 when the mutation was present and 0 when there was no mutation. In addition to that, mutation hotspots at some genes were also taken into account. To complicate things more, annotation of hotspots was performed differently depending on the specific gene and mutational effect. Specifically, the CREBBP missemse mutations were considered hotspots when they occured in the KAT domain, but not outside of it. The mutations in FOXO1 were considered hotspots when the AA change was at M1. GAMBLR.data provides a one-stop shop to achieve this level of details out-of-the-box in a simple and convenient way with get_coding_ssm_status functions. It has a logical arguments include_hotspots to separate regular mutations from the ones occurring at hotspots, and review_hotspots, which will handle the specific cases we described above in an automated way. Both of these arguments are TRUE by default, so you do not need to toggle them separately, but in this exaple we will specify them explicitly just to illustrate that this will happen during the function call. To keep the example clean and concise, we will also annotate the mutation status only for a few of selected genes.\n\n# Specify genes to annotate\nour_genes &lt;- c(\n    \"CREBBP\", \"MYD88\", \"RRAGC\",\n    \"PIM1\", \"BCL2\", \"BCL6\"\n)\n\n# Generate binary matrix\ncoding_matrix &lt;- get_coding_ssm_status(\n    gene_symbols = our_genes,\n    these_samples_metadata = metadata,\n    maf_data = maf,\n    include_hotspots = TRUE,\n    review_hotspots = TRUE\n)\n\ncoding_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n\n\nWe can see that in this example there is only one sample with hotspot mutation in CREBBP, SP59424 (annotated as 1 in the column CREBBPHOTSPOT). Let’s sanity check this annotation for illustration purposes:\n\ncrebbp_hotspot_mutation &lt;- maf %&gt;%\n    filter(\n        Tumor_Sample_Barcode == \"SP59424\",\n        Hugo_Symbol == \"CREBBP\"\n    ) %&gt;%\n    select(Chromosome, Start_Position, Variant_Classification)\n\ncrebbp_hotspot_mutation\n\n   Chromosome Start_Position Variant_Classification\n1:         16        3788650      Missense_Mutation\n\n\nThis mutation falls within KAT domain and is a missense variant, so it is indeed correct to be annotated as hotspot. How can we check it does fall within KAT domain? It is easy with GAMBLR.data:\n\n# GAMBLR.data has the regions to be considered as hotspots\nhotspot_regions_grch37\n\n               chrom     start       end\nCREBBP            16   3785000   3791000\nEZH2               7 148508764 148506238\nNOTCH1             9 139391455 139391455\nNOTCH2             1 120459150 120459150\nCD79B_trunc       17  62007172  62007172\nCD79B_NONtrunc    17  62006800  62006800\n\n# Now check that CREBBP mutations\nbetween(\n    crebbp_hotspot_mutation$Start_Position,\n    hotspot_regions_grch37[\"CREBBP\", \"start\"],\n    hotspot_regions_grch37[\"CREBBP\", \"end\"]\n)\n\n[1] TRUE\n\n\nWe have now generated matrix of coding mutations and SSM hotspots in a binary format and are ready to proceed to the next step.\n\n\n\nThe FL study also annotated the non-coding mutations at selected aSHM targets as features of binary matrix. Again, all the necessarily means to do it in a simple step are provided by GAMBLR.data. The regions targeted by aSHM are available in the GAMBLR.data. Since they are always complemented with new regions once they are identified, the latest and most comprehensive version is always available by referring to {projection}_ashm_regions. However, this use case is a perfect exmple to demonstarate how to operate on versioned iterations of the aSHM target list, as the list has been updated since the time the study was published and at the time of publication version 0.2 was used. We can refer to it directly by the version number:\n\nregions_bed &lt;- somatic_hypermutation_locations_GRCh37_v0.2\n\nhead(regions_bed)\n\n  chr_name hg19_start  hg19_end    gene     region regulatory_comment\n1     chr2   96808901  96811913   DUSP2   intron-1           enhancer\n2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer\n3    chr11  128339774 128345731    ETS1    introns           enhancer\n4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter\n5     chr6   31548325  31550717     LTB   intron-1           enhancer\n6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter\n\n\nWe will perform some simple modifications to it to make our experience better and only select few regions for illustrative purposes:\n\nour_regions &lt;- c(\n    \"BCL6-TSS\",\n    \"BCL7A-TSS\",\n    \"RHOH-TSS\",\n    \"ZFP36L1-TSS\"\n)\n\nregions_bed &lt;- regions_bed %&gt;%\n    mutate(\n        name = paste(gene, region, sep = \"-\")\n    ) %&gt;%\n    filter(\n        name %in% our_regions\n    )\n\nregions_bed\n\n  chr_name hg19_start  hg19_end    gene region regulatory_comment        name\n1     chr3  187458526 187464632    BCL6    TSS               &lt;NA&gt;    BCL6-TSS\n2    chr12  122456912 122464036   BCL7A    TSS    poised_promoter   BCL7A-TSS\n3    chr14   69257848  69259739 ZFP36L1    TSS    active_promoter ZFP36L1-TSS\n4     chr4   40193105  40204231    RHOH    TSS    active_promoter    RHOH-TSS\n\n\nNow we can see whether or not there are any mutations within these regions:\n\nashm_matrix &lt;- get_ashm_count_matrix(\n    regions_bed = regions_bed,\n    maf_data = maf,\n    these_samples_metadata = metadata\n)\n\nashm_matrix\n\n        BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\nSP59412        4           1         0        0\nSP59448        6           4        14        3\nSP59452       18           2        12       28\nSP59456        2           6         0        9\nSP59460        1           1         1        2\nSP59420        1           0         1        0\nSP59424        0           0         0        1\nSP59432        0           0         0        0\nSP59436        1           0         0        0\nSP59464        1           0         0        0\n\n\nWe how calculated the number of mutations in each region for each sample. The original study used pathology-specific values per region to convert these counts to binary, but here we will use a cutoff of 5 to binarize these counts. We will also convert rownames to column so it will be easier for us to unite all matrices into single one at the later steps:\n\nashm_matrix[ashm_matrix &lt;= 5] = 0\nashm_matrix[ashm_matrix &gt; 5] = 1\nashm_matrix &lt;- ashm_matrix %&gt;%\n    rownames_to_column(\"sample_id\")\n\nashm_matrix\n\n   sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1    SP59412        0           0         0        0\n2    SP59448        1           0         1        0\n3    SP59452        1           0         1        1\n4    SP59456        0           1         0        1\n5    SP59460        0           0         0        0\n6    SP59420        0           0         0        0\n7    SP59424        0           0         0        0\n8    SP59432        0           0         0        0\n9    SP59436        0           0         0        0\n10   SP59464        0           0         0        0\n\n\nWe have now generated matrix of non-coding mutations in a binary format and are ready to unite all matrices together.\n\n\n\nWe can now combine both coding and non-coding mutations into single matrix:\n\nfeature_matrix &lt;- left_join(\n    coding_matrix,\n    ashm_matrix\n)\n\nfeature_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n   BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1         0           0         0        0\n2         1           0         1        0\n3         1           0         1        1\n4         0           1         0        1\n5         0           0         0        0\n6         0           0         0        0\n7         0           0         0        0\n8         0           0         0        0\n9         0           0         0        0\n10        0           0         0        0\n\n\nThat’s it!\nHappy GAMBLing!"
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installation",
    "section": "",
    "text": "Installation\nWe recommend installing the package directly from GitHub (requires devtools dependency).\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n)\nYou can confirm successful installation by running some of the easy and most popular commands:\nget_gambl_metadata() # returns simple metadata data frame\nget_coding_ssm() # returns data frame in maf formatting with somatic variants\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAMBLR.data",
    "section": "",
    "text": "Why use GAMBLR.data?\n  \n  \n    \n     How to install?\n  \n  \n    \n     How to use?\n  \n  \n    \n     Release notes\n  \n  \n    \n     GitHub"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "GAMBLR.data",
    "section": "Install",
    "text": "Install\nWe recommend installing the package directly from GitHub (requires devtools dependency).\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n1)\n\n1\n\nInstall GAMBLR.data directly from GitHub along with all bundled data.\n\n\n\n\n\nShow quickstart"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "GAMBLR.data",
    "section": "Quickstart",
    "text": "Quickstart\nThe quick and easy way to get started is to make sure the devtools dependency is installed, then install the GAMBLR.data and run a simple function that returns metadata to confirm successful setup:\n# Verify devtools is installed\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\n# Install GAMBLR.data\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n)\n\n# Confirm successful setup\nget_gambl_metadata() # returns simple metadata data frame\nget_coding_ssm() # returns data frame in maf formatting with somatic variants"
  },
  {
    "objectID": "index.html#installation-for-developers",
    "href": "index.html#installation-for-developers",
    "title": "GAMBLR.data",
    "section": "Installation for developers",
    "text": "Installation for developers\nThe easiest way to obtain and contribute to GAMBLR.data is to do this via cloning the repository\ncd\ngit clone git@github.com:morinlab/GAMBLR.data.git\nIn your R editor of choice (which is hopefully VS Code now), set your working directory to the place you just cloned the repo.\nsetwd(\"~/GAMBLR.data\")\nInstall the package in R by running the following command (requires the devtools package):\ndevtools::install()\nAfter applying your modifications to the code, use the following command to quickly test your changes without directly installing the packaage (requires the devtools dependency):\ndevtools::load_all()\nGAMBLR.data is a free open-source package, but the Master branch is protected. We welcome contributions (pull request, bug report, feature request, PR review) from all levels of users. All commits must be submitted via pull request on a branch. Please refer to the GitHub documentation for details on how to do pull request."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "why.html",
    "href": "why.html",
    "title": "Why GAMBLR.data?",
    "section": "",
    "text": "GAMBLR.data is an open-source portable R library.\nIf you’ve had issues with importing genomic data from large-scale lymphoma studies, need to work with standardized data used for analysis of somatic variants, find yourself translating between different genome build systems, or just want a great great comprehensive resource of genomic data in B-cell lymphomas, GAMBLR.data is for you.\nGAMBLR stands for Genomic Analysis of Mature B-cell Lymphomas in R, and is part of the family of R packages for lymphoma cancer research developed in the Morin Lab at the Simon Fraser University."
  },
  {
    "objectID": "why.html#gamblr-family",
    "href": "why.html#gamblr-family",
    "title": "Why GAMBLR.data?",
    "section": "GAMBLR family",
    "text": "GAMBLR family\nGAMBLR.data is part of a larger family of R tools for the analysis of lymphoma genomic data.\nIt is designed to mainly serve as a storage of bundled data resources and works well with other tools in the GAMBLR family. We continue to bundle more data available through this package, as well as improve it’s functionality.\nFor more details, please refer to the GAMBLR family section."
  },
  {
    "objectID": "why.html#local-experience",
    "href": "why.html#local-experience",
    "title": "Why GAMBLR.data?",
    "section": "Local experience",
    "text": "Local experience\nThe data bundled with the GAMBLR.data is immediately available upon package installation and does not require internet connection or ssh access to GSC resources. It can run anywhere that R is available without restrictions and limitations."
  },
  {
    "objectID": "why.html#use-cases",
    "href": "why.html#use-cases",
    "title": "Why GAMBLR.data?",
    "section": "Use cases",
    "text": "Use cases\nYou can use GAMBLR.data at any stage of your lymphoma data analysis workflow.\nGAMBLR.data helps with:\n\none-stop shop to obtain somatic variants from BL, DLBCL, and FL cases (studies by Thomas et al, Dreval et al, Schmitz et al, Chapuy et al, Reddy et al.) and variant calls from some DLBCL cell lines.\nQC metrics from major WGS and WEX studies of B-cell lymphomas (as reported in Dreval et al.)\nCurated lists of lymphoma genes for all major pathologies\nCurated list of regions targeted by aSHM in B-cell lymphomas\nCoordinates of chromosome arms in both genome projections\nGene coordinates in both genome projections\nCoordinates of oncogenes and SV partners in both genome projections\nHotspot regions for selected genes in both projections\nOther resources\n\nFor more details, please refer to the bundled data section."
  },
  {
    "objectID": "why.html#community",
    "href": "why.html#community",
    "title": "Why GAMBLR.data?",
    "section": "Community",
    "text": "Community\nCommunity discussions primarily happen through issue submission on GitHub."
  },
  {
    "objectID": "why.html#getting-started",
    "href": "why.html#getting-started",
    "title": "Why GAMBLR.data?",
    "section": "Getting started",
    "text": "Getting started\nIf you’re interested in trying GAMBLR.data we recommend the getting started tutorial."
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Qestions",
    "section": "",
    "text": "This section will cover most of the questions you may have about GAMBLR.data. If there is something that is not covered, please feel free to reach out to us via GitHub by reporting an issue and we will be happy to add it to this page."
  },
  {
    "objectID": "faq.html#what-exactly-is-meant-by-lymphoma-genes",
    "href": "faq.html#what-exactly-is-meant-by-lymphoma-genes",
    "title": "Frequently Asked Qestions",
    "section": "What exactly is meant by “lymphoma genes”?",
    "text": "What exactly is meant by “lymphoma genes”?\nThe term lymphoma genes refers to the curated list of genes significantly mutated in mature B-cell lymphomas. This list is available within this package by simply calling lymphoma_genes. Several modifications of the curated list are available, including the lists split by pathology, and a more comprehensive list lymphoma_genes_comprehensive that provides more information such as which studies reported it as significantly mutated, whether it is target of aSHM etc."
  },
  {
    "objectID": "faq.html#someone-said-ashm-regions.-what-is-this",
    "href": "faq.html#someone-said-ashm-regions.-what-is-this",
    "title": "Frequently Asked Qestions",
    "section": "Someone said “aSHM regions”. What is this?",
    "text": "Someone said “aSHM regions”. What is this?\nThe GAMBLR.data comes with the list of aSHM regions. They are determined by variety of approaches but mostly by manually reviewing patters of thousands of variants across multiple lymphomas. They can be obtained by simply calling {projection}_ashm_regions. The aSHM regions are version-controlled to track the previous iterations of the list, but the {projection}_ashm_regions always refers to the latest and most complete version. If you want to access the previous iterations, they can be referred to as somatic_hypermutation_locations_GRCh3{projection_version}_v{version}. For more details please refer to the bundled data resources."
  },
  {
    "objectID": "faq.html#what-kind-of-somatic-variants-are-bundled",
    "href": "faq.html#what-kind-of-somatic-variants-are-bundled",
    "title": "Frequently Asked Qestions",
    "section": "What kind of somatic variants are bundled?",
    "text": "What kind of somatic variants are bundled?\nThe GAMBLR.data provides simple somatic, copy number, and structural variants. For data that comes directly from the Supplemental Tables of supported studies, it is provided in the projection as reported in the original publications. For the rest of the samples it is available with respect to both grch37 and hg38."
  },
  {
    "objectID": "faq.html#what-are-the-studies-bundled-with-the-package",
    "href": "faq.html#what-are-the-studies-bundled-with-the-package",
    "title": "Frequently Asked Qestions",
    "section": "What are the studies bundled with the package?",
    "text": "What are the studies bundled with the package?\nThe data includes variants from the following studies:\n\n\n                  \n                    BL BLL COMFL DLBCL  FL HGBL MZL NS1\n  BL_Thomas        234   0     0     0   0    0   0   0\n  DLBCL_Arthur       0   0     1   152   0    0   0   0\n  DLBCL_cell_lines   0   0     0     5   0    0   0   0\n  dlbcl_chapuy       0   0     0   233   0    0   0   0\n  DLBCL_Hilton       0   1     9   137   6    5   1   1\n  dlbcl_reddy        0   0     0   999   0    0   0   0\n  dlbcl_schmitz      0   0     0   470   0    0   0   0\n  DLBCL_Thomas       0   0     0    43   0    0   0   0\n  FL_Dreval          0   0    21   209 213    0   0   0\n\n\nPlease see the use cases for the more information on each of these studies."
  },
  {
    "objectID": "faq.html#which-variant-caller-is-used-to-call-the-variants",
    "href": "faq.html#which-variant-caller-is-used-to-call-the-variants",
    "title": "Frequently Asked Qestions",
    "section": "Which variant caller is used to call the variants?",
    "text": "Which variant caller is used to call the variants?\nThe simple somatic mutations are called using the SLMS-3 variant caller. Briefly, this is a voting approach of strelka2, mutect2, LoFreq, and SAGE. For more details about SLMS-3, please refer to the source code and manuscript by Thomas et al.. For copy number variants, the calls for WGS samples are obtained using battenberg or sequenza when the samples are matched, and contolfreec when the samples are unmatched. The samples subjected to whole exome sequencing, the copy number variants are called with battenberg for matched samples, and combination of cnvkit/pureCN for samples without matched normal sample. The structural variants are called using manta."
  },
  {
    "objectID": "faq.html#are-the-variant-calls-reported-for-throughout-the-whole-genome-space",
    "href": "faq.html#are-the-variant-calls-reported-for-throughout-the-whole-genome-space",
    "title": "Frequently Asked Qestions",
    "section": "Are the variant calls reported for throughout the whole genome space?",
    "text": "Are the variant calls reported for throughout the whole genome space?\nThe data for BL samples from the manuscript by Thomas et al. and FL/DLBCL samples from the manuscript by Dreval et al. are directly pulled from the Supplemental Tables. They represent only coding variants. The rest of the simple somatic variants are restricted to only coding variants in lymphoma genes."
  },
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "This is a quick tour of some basic commands and usage patterns, just to get you started.\n\n# Load packages\nlibrary(GAMBLR.data)\nlibrary(tidyverse)\n\nThis tutorial explores how to retrieve different data types bundled within GAMBLR.data. Commonly, GAMBLR functions are prefixed with get_. These functions are readily available for returning data of different types: Simple Somatic Mutations (SSM), Copy Number (CN) segments and Structural Variants (SV). This resource explores commonly occurring arguments across different functions, best-practices and recommendations in the scope of retrieving data.\n\n\nFirst, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2740 obs. of  29 variables:\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ genome_build        : chr  NA NA NA NA ...\n $ pairing_status      : chr  NA NA NA NA ...\n $ age_group           : chr  NA NA NA NA ...\n $ compression         : chr  NA NA NA NA ...\n $ bam_available       : logi  NA NA NA NA NA NA ...\n $ pathology_rank      : num  NA NA NA NA NA NA NA NA NA NA ...\n $ DHITsig_consensus   : chr  NA NA NA NA ...\n $ ffpe_or_frozen      : chr  NA NA NA NA ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen_cnv_noA53  : chr  NA NA NA NA ...\n $ lymphgen_no_cnv     : chr  NA NA NA NA ...\n $ lymphgen_with_cnv   : chr  NA NA NA NA ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ time_point          : chr  NA NA NA NA ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nBased on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    45\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    45\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nReturning maf data for thousands or hundreds of files can potentially create memory or space issues when storing the Rsession if you are using old-day R editors like RStudio. To facilitate this, you can optionally request the SSM to be returned just for a small number of specific genes with the argument these_genes:\n\n# Only look at specific gene(s)\nmy_genes &lt;- c(\"MYC\")\n\nssm_myc &lt;- get_ssm_by_samples(\n    these_sample_ids = my_sample_id,\n    these_genes = my_genes\n)\n\nssm_myc %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nSimilarly, to decrease the burden of handling large maf data, it is also possible to dictate what maf columns we want back. To do this, call the function with the maf_col argument and provide a vector of the columns of interest. Here, we are requesting SSM calls for only a small set of columns. It is also important to note that this will require setting the argument basic_columns to FALSE, as this argument takes precedence over all other arguments that control output columns and returns first 45 columns of standard maf.\n\n# Define the column names\nmy_columns &lt;- c(\n    \"Hugo_Symbol\",\n    \"Chromosome\",\n    \"Start_Position\",\n    \"End_Position\",\n    \"Tumor_Sample_Barcode\",\n    \"Variant_Classification\"\n)\n\n# Since we don't provide any arguments that restrict to specific\n# samples, we expect the return to contain data from all samples in the bundled\n# data\nssm_col &lt;- get_ssm_by_samples(\n    these_genes = my_genes,\n    maf_col = my_columns,\n    basic_columns = FALSE\n)\n\n# What are the dimensions for the capture SSM calls?\ndim(ssm_col)\n\n[1] 4000    6\n\n# What are the columns in the output?\ncolnames(ssm_col)\n\n[1] \"Hugo_Symbol\"            \"Chromosome\"             \"Start_Position\"        \n[4] \"End_Position\"           \"Tumor_Sample_Barcode\"   \"Variant_Classification\"\n\n\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it by default returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nFor multiple regions, refer to the get_ssm_by_regions. In this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this multiple-region-version of this function we also get the region name added to the returned data frame and there are a couple of different ways this can be done. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns. Don’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- grch37_ashm_regions %&gt;%\n    filter(gene == ashm_gene) %&gt;%\n    rename(\n        chromosome = chr_name,\n        start = hg19_start,\n        end = hg19_end\n    ) %&gt;%\n    mutate(\n        name = paste0(gene, \"_\", region)\n    )\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    regions_bed = regions,\n    use_name_column = TRUE,\n    streamlined = TRUE\n)\n\nhead(ashm_ssm)\n\n# A tibble: 6 × 3\n     start sample_id region_name  \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        \n1 37025887 01-20260T PAX5_intron-1\n2 37024351 04-24937T PAX5_intron-1\n3 37025246 04-24937T PAX5_intron-1\n4 37025268 04-24937T PAX5_intron-1\n5 37025300 04-24937T PAX5_intron-1\n6 37025820 04-24937T PAX5_intron-1\n\n\n\n\nYou can instead specify regions as a vector of characters (regions_list) instead of using a bed file. In this case, the function will not accept a fourth element for naming the returned regions. If so, the function defaults to using the specified region as the name of the column in the output.\n\nssm_region_list &lt;- get_ssm_by_regions(\n    regions_list = c(\n        \"chr9:37023396-37027663\",\n        \"chr9:37029849-37037154\",\n        \"chr9:37369209-37372160\"\n    ),\n    streamlined = TRUE\n)\n\nhead(ssm_region_list)\n\n# A tibble: 6 × 3\n     start sample_id region_name           \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;                 \n1 37025887 01-20260T chr9:37023396-37027663\n2 37024351 04-24937T chr9:37023396-37027663\n3 37025246 04-24937T chr9:37023396-37027663\n4 37025268 04-24937T chr9:37023396-37027663\n5 37025300 04-24937T chr9:37023396-37027663\n6 37025820 04-24937T chr9:37023396-37027663\n\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# Limit_cohort\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    limit_cohort = \"DLBCL_cell_lines\"\n)\n\ndim(dlbcl_cell_lines)\n\n[1] 1616   48\n\n\nInstead, we can just exclude a group of samples by using the exclude_cohort argument:\n\n# Exclude_cohort\nno_dlbcl_cell_lines &lt;- get_coding_ssm(\n    exclude_cohort =  \"DLBCL_cell_lines\"\n)\ndim(no_dlbcl_cell_lines)\n\n[1] 57230    48\n\n\n\n\n\n\nFor the purpose of retrieving CN data, we have two functions available: get_sample_cn_segments and get_sn_segments, each with its own specialized application and recommended usage. Briefly, get_sample_cn_segments is best called if you want to query CN segments for a specific subset of samples. This function works for singular as well as multiple samples. In addition, many arguments and their behavior might be already familiar to you from the previous section (such as this_seq_type, projection, these_sample_ids, and these_samples_metadata). If you instead want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will explore the two different functions and demonstrate how they can be used.\n\n\nget_sample_cn_segments returns CN segments in seg format for single sample or multiple samples. Specify the sample IDs you are interested in with these_sample_ids (as a vector of characters), or call this function with these_samples_metadata if you already have a metadata table subset to the sample IDs of interest. If none of the above arguments are specified, the function will return CN segments for available samples (from get_gambl_metadata) - a behaviour consistent with other functions of the get_ GAMBLR family. As some downstream tools do not allow for missing segments in the CN data for proper functioning, this is already handled for you when obtaining CN data. The “bald spots” where CN callers did not report any variants are filled in with empty segments of diploid state, and extend through the whole chromosome arm, omitting centromeres.\n\n\nTo begin, let’s call get_sample_cn_segments with default arguments. This returns all available CN information from the bundled data. Consistent with other functions of the get_ GAMBLR family, the default seq_type is always set to genome and default projection set to grch37.\n\nseg &lt;- get_sample_cn_segments()\n\n# What are the columns we have available?\nhead(seg)\n\n# A tibble: 6 × 7\n  ID        chrom     start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 02-13135T 1         10001    762600        0     0         2\n2 02-13135T 1        762601 121500000        0     0         2\n3 02-13135T 1     142600000 161506889        0     0         2\n4 02-13135T 1     161506890 161652716        0     0         2\n5 02-13135T 1     161652717 162110568        0     0.728     3\n6 02-13135T 1     162110569 162111399        0     0         2\n\n\n\n\n\nNow, let’s explore some of the other arguments we have available. In this example, we are calling the function specifying these_sample_ids to obtain CN data for a sample of interest.\n\n# Use these_sample_ids\nsample_dohh2_seg &lt;- get_sample_cn_segments(\n    these_sample_ids = my_sample_id\n)\n\nhead(sample_dohh2_seg)\n\n# A tibble: 6 × 7\n  ID     chrom     start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 DOHH-2 1         10001  86026719        0         0     2\n2 DOHH-2 1      86026720  86688464        1         0     2\n3 DOHH-2 1      86688465 121499999        0         0     2\n4 DOHH-2 1     142600001 249250620        0         0     2\n5 DOHH-2 2         10001  89087285        0         0     2\n6 DOHH-2 2      89087286  89997184        1       -10     0\n\n\n\n\n\nWe can also use metadata restricted to the sample ID of interest to demonstrate that either of these arguments will return the same data, as long as they have the same sample ID.\n\n# Use these_samples_metadata\nmeta_dohh2_seg &lt;- get_sample_cn_segments(\n    these_samples_metadata = metadata$dohh2\n)\n\n# Are they the same?\nidentical(\n    sample_dohh2_seg,\n    meta_dohh2_seg\n)\n\n[1] TRUE\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call get_sample_cn_segments\ndlbcl_samples_seg &lt;- get_sample_cn_segments(\n    these_sample_ids = metadata$dlbcl$sample_id,\n    projection = \"hg38\"\n)\n\nhead(dlbcl_samples_seg)\n\n# A tibble: 6 × 7\n  ID                        chrom    start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;                     &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 HTMCP-01-01-00003-01D-03D 1        10001    832872       NA     0         2\n2 HTMCP-01-01-00003-01D-03D 1       832873  23215653       NA     0         2\n3 HTMCP-01-01-00003-01D-03D 1     23215654  23216813       NA     0         2\n4 HTMCP-01-01-00003-01D-03D 1     23216814  23789186       NA    -0.731     1\n5 HTMCP-01-01-00003-01D-03D 1     23789187  23795110       NA     0         2\n6 HTMCP-01-01-00003-01D-03D 1     23795111 121608415       NA     0         2\n\ndlbcl_meta_seg &lt;- get_sample_cn_segments(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\"\n)\n\n# Are they the same?\nidentical(dlbcl_samples_seg, dlbcl_meta_seg)\n\n[1] TRUE\n\n\n\n\n\n\nget_cn_segments behaves very similar to get_sample_cn_segments with the difference that you can specify one or more genomic loci to restrict the returned CN segments to. In order to achieve this, the function has the following additional arguments available; region, chromosome, qstart, and qend. You can provide the full region in a “region” format (chr:start-end) to the region argument. Alternatively, you can provide chromosome, start, and end coordinates individually with chr, qstart, and qend arguments.\n\n\nHere we are showing how to give the function a complete region with the region argument. Similar to get_sample_cn_segments, if these_sample_ids and/or these_samples_metadata are not specified, the function will query all available samples.\n\n# MYC region (grch37)\nmyc_region &lt;- \"8:128747680-128753674\"\n\n# Get cn segments in this region for all samples\nmyc_seg &lt;- get_cn_segments(\n    region = myc_region\n)\n\n# What are the CN states in this region for the selected samples?\nmyc_seg %&gt;%\n    count(CN) %&gt;%\n    ggplot(\n        aes(\n            x = CN,\n            y = n,\n            fill = CN\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nHere we specify the region of interest with the chromosome, qstart, and qend arguments. As a quick check, we are also comparing the returned data frame with what we get when specifying the same region with the region argument to ensure they are identical.\n\nmyc_chunks_seg &lt;- get_cn_segments(\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674\n)\n\n# Does this return match what we get when specifying the same genomic range\n# with `range` in the previous example?\nidentical(\n    myc_seg,\n    myc_chunks_seg\n)\n\n[1] TRUE\n\n\nYes, indeed - the both ways of returning the CN data for a given region produce identical outputs.\n\n\n\n\n\nIn this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. Similar to the previously described SSM and CNV functionalities, this function can also restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples. In addition, you can chose to obtain all variants, even the ones not passing the filter criteria. To do so, set pass = FALSE (default is TRUE).\n\n\nThis function also operates on the same set of familiar arguments as the family of get_ functions in GAMBLR. For example, to obtain SV calls for multiple samples, give these_sample_ids a vector of sample IDs. It will return the identical output as when the subsetting is done using these_samples_metadata. When none of this is specified, the returned output contains SVs for all samples available.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nHere we are demonstrating the sample ID subset option.\n\n# Use these_sample_ids\nsample_dohh2_manta &lt;- get_manta_sv(\n    these_sample_ids = my_sample_id\n)\n\nhead(sample_dohh2_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1      14 106329465 106329465      18  60793497  60793497\n2      14 106379091 106379091      18  60793492  60793492\n3       8 128748200 128748200      14 106114286 106114286\n4       8 128748204 128748205      14 106114282 106114283\n                   manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1   MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n2   MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n3 MantaBND:135279:0:1:0:0:0:0    84        +        -           DOHH-2\n4 MantaBND:135279:0:1:0:0:0:0    83        -        +           DOHH-2\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N       0.29 69   unmatched   PASS\n2        14-11247N       0.30 60   unmatched   PASS\n3        14-11247N       0.70 20   unmatched   PASS\n4        14-11247N       0.65 20   unmatched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\nmeta_dohh2_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dohh2\n)\n\n# Are they the same?\nidentical(\n    sample_dohh2_manta,\n    meta_dohh2_manta\n)\n\n[1] TRUE\n\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n# Specifying MYC in region format\ndohh2_myc_manta_region &lt;- get_manta_sv(\n    these_sample_ids = my_sample_id,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0,\n    pass = FALSE\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\ndohh2_myc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dohh2,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0,\n    pass = FALSE\n)\n\n# Are the returned data frames the same?\nidentical(\n    dohh2_myc_manta_region,\n    dohh2_myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 65\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE"
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "href": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "First, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2740 obs. of  29 variables:\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ genome_build        : chr  NA NA NA NA ...\n $ pairing_status      : chr  NA NA NA NA ...\n $ age_group           : chr  NA NA NA NA ...\n $ compression         : chr  NA NA NA NA ...\n $ bam_available       : logi  NA NA NA NA NA NA ...\n $ pathology_rank      : num  NA NA NA NA NA NA NA NA NA NA ...\n $ DHITsig_consensus   : chr  NA NA NA NA ...\n $ ffpe_or_frozen      : chr  NA NA NA NA ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen_cnv_noA53  : chr  NA NA NA NA ...\n $ lymphgen_no_cnv     : chr  NA NA NA NA ...\n $ lymphgen_with_cnv   : chr  NA NA NA NA ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ time_point          : chr  NA NA NA NA ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )"
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "href": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "Based on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    45\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    45\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nReturning maf data for thousands or hundreds of files can potentially create memory or space issues when storing the Rsession if you are using old-day R editors like RStudio. To facilitate this, you can optionally request the SSM to be returned just for a small number of specific genes with the argument these_genes:\n\n# Only look at specific gene(s)\nmy_genes &lt;- c(\"MYC\")\n\nssm_myc &lt;- get_ssm_by_samples(\n    these_sample_ids = my_sample_id,\n    these_genes = my_genes\n)\n\nssm_myc %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nSimilarly, to decrease the burden of handling large maf data, it is also possible to dictate what maf columns we want back. To do this, call the function with the maf_col argument and provide a vector of the columns of interest. Here, we are requesting SSM calls for only a small set of columns. It is also important to note that this will require setting the argument basic_columns to FALSE, as this argument takes precedence over all other arguments that control output columns and returns first 45 columns of standard maf.\n\n# Define the column names\nmy_columns &lt;- c(\n    \"Hugo_Symbol\",\n    \"Chromosome\",\n    \"Start_Position\",\n    \"End_Position\",\n    \"Tumor_Sample_Barcode\",\n    \"Variant_Classification\"\n)\n\n# Since we don't provide any arguments that restrict to specific\n# samples, we expect the return to contain data from all samples in the bundled\n# data\nssm_col &lt;- get_ssm_by_samples(\n    these_genes = my_genes,\n    maf_col = my_columns,\n    basic_columns = FALSE\n)\n\n# What are the dimensions for the capture SSM calls?\ndim(ssm_col)\n\n[1] 4000    6\n\n# What are the columns in the output?\ncolnames(ssm_col)\n\n[1] \"Hugo_Symbol\"            \"Chromosome\"             \"Start_Position\"        \n[4] \"End_Position\"           \"Tumor_Sample_Barcode\"   \"Variant_Classification\"\n\n\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it by default returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nFor multiple regions, refer to the get_ssm_by_regions. In this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this multiple-region-version of this function we also get the region name added to the returned data frame and there are a couple of different ways this can be done. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns. Don’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- grch37_ashm_regions %&gt;%\n    filter(gene == ashm_gene) %&gt;%\n    rename(\n        chromosome = chr_name,\n        start = hg19_start,\n        end = hg19_end\n    ) %&gt;%\n    mutate(\n        name = paste0(gene, \"_\", region)\n    )\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    regions_bed = regions,\n    use_name_column = TRUE,\n    streamlined = TRUE\n)\n\nhead(ashm_ssm)\n\n# A tibble: 6 × 3\n     start sample_id region_name  \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        \n1 37025887 01-20260T PAX5_intron-1\n2 37024351 04-24937T PAX5_intron-1\n3 37025246 04-24937T PAX5_intron-1\n4 37025268 04-24937T PAX5_intron-1\n5 37025300 04-24937T PAX5_intron-1\n6 37025820 04-24937T PAX5_intron-1\n\n\n\n\nYou can instead specify regions as a vector of characters (regions_list) instead of using a bed file. In this case, the function will not accept a fourth element for naming the returned regions. If so, the function defaults to using the specified region as the name of the column in the output.\n\nssm_region_list &lt;- get_ssm_by_regions(\n    regions_list = c(\n        \"chr9:37023396-37027663\",\n        \"chr9:37029849-37037154\",\n        \"chr9:37369209-37372160\"\n    ),\n    streamlined = TRUE\n)\n\nhead(ssm_region_list)\n\n# A tibble: 6 × 3\n     start sample_id region_name           \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;                 \n1 37025887 01-20260T chr9:37023396-37027663\n2 37024351 04-24937T chr9:37023396-37027663\n3 37025246 04-24937T chr9:37023396-37027663\n4 37025268 04-24937T chr9:37023396-37027663\n5 37025300 04-24937T chr9:37023396-37027663\n6 37025820 04-24937T chr9:37023396-37027663\n\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# Limit_cohort\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    limit_cohort = \"DLBCL_cell_lines\"\n)\n\ndim(dlbcl_cell_lines)\n\n[1] 1616   48\n\n\nInstead, we can just exclude a group of samples by using the exclude_cohort argument:\n\n# Exclude_cohort\nno_dlbcl_cell_lines &lt;- get_coding_ssm(\n    exclude_cohort =  \"DLBCL_cell_lines\"\n)\ndim(no_dlbcl_cell_lines)\n\n[1] 57230    48"
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "For the purpose of retrieving CN data, we have two functions available: get_sample_cn_segments and get_sn_segments, each with its own specialized application and recommended usage. Briefly, get_sample_cn_segments is best called if you want to query CN segments for a specific subset of samples. This function works for singular as well as multiple samples. In addition, many arguments and their behavior might be already familiar to you from the previous section (such as this_seq_type, projection, these_sample_ids, and these_samples_metadata). If you instead want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will explore the two different functions and demonstrate how they can be used.\n\n\nget_sample_cn_segments returns CN segments in seg format for single sample or multiple samples. Specify the sample IDs you are interested in with these_sample_ids (as a vector of characters), or call this function with these_samples_metadata if you already have a metadata table subset to the sample IDs of interest. If none of the above arguments are specified, the function will return CN segments for available samples (from get_gambl_metadata) - a behaviour consistent with other functions of the get_ GAMBLR family. As some downstream tools do not allow for missing segments in the CN data for proper functioning, this is already handled for you when obtaining CN data. The “bald spots” where CN callers did not report any variants are filled in with empty segments of diploid state, and extend through the whole chromosome arm, omitting centromeres.\n\n\nTo begin, let’s call get_sample_cn_segments with default arguments. This returns all available CN information from the bundled data. Consistent with other functions of the get_ GAMBLR family, the default seq_type is always set to genome and default projection set to grch37.\n\nseg &lt;- get_sample_cn_segments()\n\n# What are the columns we have available?\nhead(seg)\n\n# A tibble: 6 × 7\n  ID        chrom     start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 02-13135T 1         10001    762600        0     0         2\n2 02-13135T 1        762601 121500000        0     0         2\n3 02-13135T 1     142600000 161506889        0     0         2\n4 02-13135T 1     161506890 161652716        0     0         2\n5 02-13135T 1     161652717 162110568        0     0.728     3\n6 02-13135T 1     162110569 162111399        0     0         2\n\n\n\n\n\nNow, let’s explore some of the other arguments we have available. In this example, we are calling the function specifying these_sample_ids to obtain CN data for a sample of interest.\n\n# Use these_sample_ids\nsample_dohh2_seg &lt;- get_sample_cn_segments(\n    these_sample_ids = my_sample_id\n)\n\nhead(sample_dohh2_seg)\n\n# A tibble: 6 × 7\n  ID     chrom     start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 DOHH-2 1         10001  86026719        0         0     2\n2 DOHH-2 1      86026720  86688464        1         0     2\n3 DOHH-2 1      86688465 121499999        0         0     2\n4 DOHH-2 1     142600001 249250620        0         0     2\n5 DOHH-2 2         10001  89087285        0         0     2\n6 DOHH-2 2      89087286  89997184        1       -10     0\n\n\n\n\n\nWe can also use metadata restricted to the sample ID of interest to demonstrate that either of these arguments will return the same data, as long as they have the same sample ID.\n\n# Use these_samples_metadata\nmeta_dohh2_seg &lt;- get_sample_cn_segments(\n    these_samples_metadata = metadata$dohh2\n)\n\n# Are they the same?\nidentical(\n    sample_dohh2_seg,\n    meta_dohh2_seg\n)\n\n[1] TRUE\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call get_sample_cn_segments\ndlbcl_samples_seg &lt;- get_sample_cn_segments(\n    these_sample_ids = metadata$dlbcl$sample_id,\n    projection = \"hg38\"\n)\n\nhead(dlbcl_samples_seg)\n\n# A tibble: 6 × 7\n  ID                        chrom    start       end LOH_flag log.ratio    CN\n  &lt;chr&gt;                     &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 HTMCP-01-01-00003-01D-03D 1        10001    832872       NA     0         2\n2 HTMCP-01-01-00003-01D-03D 1       832873  23215653       NA     0         2\n3 HTMCP-01-01-00003-01D-03D 1     23215654  23216813       NA     0         2\n4 HTMCP-01-01-00003-01D-03D 1     23216814  23789186       NA    -0.731     1\n5 HTMCP-01-01-00003-01D-03D 1     23789187  23795110       NA     0         2\n6 HTMCP-01-01-00003-01D-03D 1     23795111 121608415       NA     0         2\n\ndlbcl_meta_seg &lt;- get_sample_cn_segments(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\"\n)\n\n# Are they the same?\nidentical(dlbcl_samples_seg, dlbcl_meta_seg)\n\n[1] TRUE\n\n\n\n\n\n\nget_cn_segments behaves very similar to get_sample_cn_segments with the difference that you can specify one or more genomic loci to restrict the returned CN segments to. In order to achieve this, the function has the following additional arguments available; region, chromosome, qstart, and qend. You can provide the full region in a “region” format (chr:start-end) to the region argument. Alternatively, you can provide chromosome, start, and end coordinates individually with chr, qstart, and qend arguments.\n\n\nHere we are showing how to give the function a complete region with the region argument. Similar to get_sample_cn_segments, if these_sample_ids and/or these_samples_metadata are not specified, the function will query all available samples.\n\n# MYC region (grch37)\nmyc_region &lt;- \"8:128747680-128753674\"\n\n# Get cn segments in this region for all samples\nmyc_seg &lt;- get_cn_segments(\n    region = myc_region\n)\n\n# What are the CN states in this region for the selected samples?\nmyc_seg %&gt;%\n    count(CN) %&gt;%\n    ggplot(\n        aes(\n            x = CN,\n            y = n,\n            fill = CN\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nHere we specify the region of interest with the chromosome, qstart, and qend arguments. As a quick check, we are also comparing the returned data frame with what we get when specifying the same region with the region argument to ensure they are identical.\n\nmyc_chunks_seg &lt;- get_cn_segments(\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674\n)\n\n# Does this return match what we get when specifying the same genomic range\n# with `range` in the previous example?\nidentical(\n    myc_seg,\n    myc_chunks_seg\n)\n\n[1] TRUE\n\n\nYes, indeed - the both ways of returning the CN data for a given region produce identical outputs."
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "In this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. Similar to the previously described SSM and CNV functionalities, this function can also restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples. In addition, you can chose to obtain all variants, even the ones not passing the filter criteria. To do so, set pass = FALSE (default is TRUE).\n\n\nThis function also operates on the same set of familiar arguments as the family of get_ functions in GAMBLR. For example, to obtain SV calls for multiple samples, give these_sample_ids a vector of sample IDs. It will return the identical output as when the subsetting is done using these_samples_metadata. When none of this is specified, the returned output contains SVs for all samples available.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nHere we are demonstrating the sample ID subset option.\n\n# Use these_sample_ids\nsample_dohh2_manta &lt;- get_manta_sv(\n    these_sample_ids = my_sample_id\n)\n\nhead(sample_dohh2_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1      14 106329465 106329465      18  60793497  60793497\n2      14 106379091 106379091      18  60793492  60793492\n3       8 128748200 128748200      14 106114286 106114286\n4       8 128748204 128748205      14 106114282 106114283\n                   manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1   MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n2   MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n3 MantaBND:135279:0:1:0:0:0:0    84        +        -           DOHH-2\n4 MantaBND:135279:0:1:0:0:0:0    83        -        +           DOHH-2\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N       0.29 69   unmatched   PASS\n2        14-11247N       0.30 60   unmatched   PASS\n3        14-11247N       0.70 20   unmatched   PASS\n4        14-11247N       0.65 20   unmatched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\nmeta_dohh2_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dohh2\n)\n\n# Are they the same?\nidentical(\n    sample_dohh2_manta,\n    meta_dohh2_manta\n)\n\n[1] TRUE\n\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n# Specifying MYC in region format\ndohh2_myc_manta_region &lt;- get_manta_sv(\n    these_sample_ids = my_sample_id,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0,\n    pass = FALSE\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\ndohh2_myc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dohh2,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0,\n    pass = FALSE\n)\n\n# Are the returned data frames the same?\nidentical(\n    dohh2_myc_manta_region,\n    dohh2_myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 65\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE"
  },
  {
    "objectID": "concepts/glossary.html",
    "href": "concepts/glossary.html",
    "title": "GAMBLR.data glossary",
    "section": "",
    "text": "There are several key concepts underlying the logic behind the GAMBLR.data package. The main terms are:\n\nprojection: This is a coordinate system defining the relationship with genome build and chromosome prefixing. The main projections supported throughout GAMBLR.data are grch37 and hg38. The grch37 projection contains the same coordinate system as genome build hg19, but never has the “chr” prefix on chromosome names. In contrast, the hg38 projection is always chr-prefixed and is in the same coordinate system as the hg38 genome build. As GAMBL itself and the data bundled and available through this package represents a large collection of samples sequenced both locally and externally, there is always a difficulty associated with proper handling of prefixes, different custom contigs and their lengths in the fasta reference, coordinates, and other distinctions complicating the direct comparison between data and comprehensive data analysis. These difficulties are handled internallyby making data always available in both projections, regardless of initial genome build to which the sample was aligned.\nmetadata: This is a data frame with a set of minimal required columns: patient_id, Tumor_Sample_Barcode, sample_id, seq_type, sex, cohort, and pathology. The columns like sex and cohort can contain NA values but must be present in the metadata. The main purpose of this data frame is to provide a structure for the metadata that is always expected to be available and provides linkage between unique sample identifiers and associated basic metadata values. The columns Tumor_Sample_Barcode and sample_id are expected to share the same values, but are required to be present for direct operation on the outputs of different upstream tools.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "resources/bundled_data.html",
    "href": "resources/bundled_data.html",
    "title": "Data bunded with GAMBLR.data",
    "section": "",
    "text": "The GAMBLR.data comes with many different bundled data objects that can be systematically organized in the following categories:"
  },
  {
    "objectID": "resources/bundled_data.html#somatic-variants",
    "href": "resources/bundled_data.html#somatic-variants",
    "title": "Data bunded with GAMBLR.data",
    "section": "Somatic variants",
    "text": "Somatic variants\n\nsample_data A list of data frames containing the metadata, simple somatic, copy number, and structural variants collected together from the supplemental tables of large sequencing studies of B-cell lymphomas."
  },
  {
    "objectID": "resources/bundled_data.html#curated-gene-lists",
    "href": "resources/bundled_data.html#curated-gene-lists",
    "title": "Data bunded with GAMBLR.data",
    "section": "Curated gene lists",
    "text": "Curated gene lists\n\ngene_blacklist A tibble with gene symbols (Hugo) that fall within blacklisted regions of the genome. The genes in this data object represent common sequencing artifacts and are discarded during the data analysis.\nlymphoma_genes A data frame with a manually curated set of genes commonly mutated in lymphomas with associated TRUE/FALSE columns annotating lymphoma type(s) where the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_bl_v0.1 A data frame with a manually curated set of genes commonly mutated in BL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred to directly by it’s version number.\nlymphoma_genes_bl_v_latest A data frame with a manually curated set of genes commonly mutated in BL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_comprehensive A data frame with the curated list of genes reported as significantly mutated in the large lymphoma studies. Both Ensembl ID and Hugo Symbol are available as gene identifiers. This data contains annotations for the studies by Chapuy, Reddy, Wright (LymphGen), Lacy, as well as annotations for whether the gene is curated, reported as SMG in other_studies, or a target of aSHM.\nlymphoma_genes_dlbcl_v0.1 A data frame with a manually curated set of genes commonly mutated in DLBCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred to directly by it’s version number.\nlymphoma_genes_dlbcl_v_latest A data frame with a manually curated set of genes commonly mutated in DLBCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_lymphoma_genes_v0.0 Legacy version of the curated list of genes significantly mutated in lymphomas. Bundled here for backwards compatibility and can be referred to directly by it’s version number.\nlymphoma_genes_mcl_v0.1 A data frame with a manually curated set of genes commonly mutated in MCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred directly by it’s version number.\nlymphoma_genes_mcl_v_latest A data frame with a manually curated set of genes commonly mutated in MCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list."
  },
  {
    "objectID": "resources/bundled_data.html#coordinate-based-resources",
    "href": "resources/bundled_data.html#coordinate-based-resources",
    "title": "Data bunded with GAMBLR.data",
    "section": "Coordinate-based resources",
    "text": "Coordinate-based resources\n\nchromosome_arms_grch37: A data frame with the chromosome arm coordinates with respect to the grch37 projection.\nchromosome_arms_hg38 A data frame with the chromosome arm coordinates with respect to the hg38 projection.\ngrch37_gene_coordinates A data frame of all gene coordinates with respect to grch37. Contains both Ensembl ID and Hugo Symbol as identifiers.\ngrch37_lymphoma_genes_bed A data frame in the bed format for genes commonly associated with B-cell lymphomas. Coordinates are with respect to grch37.\ngrch37_oncogene A data frame with the coordinates of lymphoma oncogenes relative to grch37. Used in mapping of the breakpoint coordinates.\ngrch37_partners A data frame of translocation partners for oncogenes with coordinates relative to grch37.\nhg38_gene_coordinates A data frame of all gene coordinates with respect to hg38. Contains both Ensembl ID and Hugo Symbol as identifiers.\nhg38_lymphoma_genes_bed A data frame in the bed format for genes commonly associated with B-cell lymphomas. Coordinates are with respect to hg38.\nhg38_oncogene A data frame with the coordinates of lymphoma oncogenes relative to the hg38. Used in mapping of the breakpoint coordinates.\nhg38_partners A data frame of translocation partners for oncogenes with relative coordinates to hg38.\ngrch37_all_gene_coordinates A data frame of protein-coding gene coordinates relative to grch37. Contains both Ensembl ID and Hugo Symbol as identifiers. Mainly here for backwards compatibility with earlier GAMBLR versions.\nhotspot_regions_grch37 A data frame of mutation hotspot regions relative to grch37.\nhotspot_regions_hg38 A data frame of mutation hotspot regions relative to hg38.\ntarget_regions_grch37 A data frame with coordinates of the regions of the genome targeted by the whole exome sequencing panel Agilent V5 (no UTR) relative to grch37.\ntarget_regions_hg38 A data frame with coordinates of the regions of the genome targeted by the whole exome sequencing panel Agilent V5 (no UTR) relative to hg38."
  },
  {
    "objectID": "resources/bundled_data.html#ashm-regions",
    "href": "resources/bundled_data.html#ashm-regions",
    "title": "Data bunded with GAMBLR.data",
    "section": "aSHM regions",
    "text": "aSHM regions\n\ngrch37_ashm_regions Aberrant somatic hypermutation (aSHM) regions relative to grch37. This object always by default refers to the most recent version of the aSHM regions.\nhg38_ashm_regions Aberrant somatic hypermutation (aSHM) regions relative to hg38. This object always by default refers to the most recent version of the aSHM regions.\nsomatic_hypermutation_locations_GRCh37_v0.0 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.1 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.2 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.3 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.4 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.5 Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v_latest Aberrant somatic hypermutation (aSHM) regions relative to grch37. This is an alias for the latest version of this data.\nsomatic_hypermutation_locations_GRCh38_v0.0 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.1 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.2 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.3 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.4 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.5 Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is the versioned data and can be referred to directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v_latest Aberrant somatic hypermutation (aSHM) regions relative to hg38. This is an alias for the latest version of this data."
  },
  {
    "objectID": "resources/bundled_data.html#other-resources",
    "href": "resources/bundled_data.html#other-resources",
    "title": "Data bunded with GAMBLR.data",
    "section": "Other resources",
    "text": "Other resources\n\ncolour_codes A data frame with colour codes (HEX) arranged into different categories, groups.\ndhitsig_genes_with_weights A data frame with double hit signature genes (both as ensembl IDs and Hugo symbols) and importance scores.\ngambl_metadata A data frame with metadata for a collection of GAMBL samples. This represents a collection of whole genome, exome, targeted, RNA, and PrometION sequencing samples available as a data set known as GAMBL. This object rather serves an FYI purpose as not all samples listed here are published and bundled with GAMBLR.data.\nhgnc2pfam.df A dataset containing the mapping table between Hugo symbol, UniProt ID, and Pfam ACC. This dataset comes from the g3viz package and was obtained via this URL: https://github.com/morinlab/g3viz/tree/master/data\nhotspots_annotations Hotspot coordinates used in the feature annotation during matrix assembly of data for cFL classifier.\nmirage_metrics A data frame providing the data reported in the Supplemental Table of the MIRAGE study by Dreval et al, 2022\nmutation.table.df A data frame providing the linkage between Variant Classification, Mutation_Class, and Short_Name for the simple somatic mutations.\nreddy_genes A data frame of the genes reported as significantly mutated by the study of Reddy et al, 2017\nwright_genes_with_weights Wright genes with weight values from the study by Scott et al, 2014."
  }
]