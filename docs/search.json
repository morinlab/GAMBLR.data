[
  {
    "objectID": "resources/functions.html",
    "href": "resources/functions.html",
    "title": "Functions overview",
    "section": "",
    "text": "The GAMBLR.data package not only stores data, but also provides some basic functionaliry to easily retreive it and operate on this data. Almost all of the functions listed below are the easier version of those in the associated package GAMBLR.results, but unlike that member of the GAMBLR family, the functions inculed here do not require you to be Morin Lab member or have access to GSC.\nThere is a limited number of basic functions available with this package as its main goal is data storage, so therefore the functions are not separated into categories. Nevertheless, these are the basic functions available:\n\nannotate_hotspots: Annotate maf data with hotsposts. Will return the same maf as input with additional logical column showing whether the particular SSM is in the hotspot region.\nassign_cn_to_ssm: Annotate maf data by assigning copy number state to SSM. Will return the same maf as input with additional column showing the absolute copy number state of the variant in that position.\ncalc_mutation_frequency_bin_region: Calculate mutation frequency by sliding window. Will return a numeric matrix with samples in rows showing number of mutations in the given window. Operates only on one given region. If you need to analyze many regions, use the plural version of this function.\ncalc_mutation_frequency_bin_regions: Calculate mutation frequency by sliding window. Will return a numeric matrix with samples in rows showing number of mutations in the given window. This function is really just a wrapper for the singular version but works on many given regions.\ncheck_excess_params: Helper function that ensures arguments given to the functions in this package are appropriate, and will drop any unsupported arguments.\ncollate_results: Collate results. This currently adds the QC metrics to the given set of samples in the metadata.\nget_ashm_count_matrix: Return matrix showing how many mutations are in the given aSHM region for each given sample.\nget_cn_segments: Return a copy mumber data in seg format in a given region.\nget_coding_ssm: Return maf data with only coding mutations.\nget_coding_ssm_status: Return a binary matrix showing whether or not each given sample is mutated in each given gene.\nget_gambl_metadata: Return metadata for the whole collection of samples present in GAMBL.\nget_manta_sv: Get SV calls returned by manta.\nget_sample_cn_segments: Return the CNV data for a given sample in a seg format.\nget_ssm_by_patients: Return maf data (both coding and non-coding mutations) for a given set of patients. This will return maf data for multiple samples if they exist for a given patient.\nget_ssm_by_region: Return maf data with variants in a single given region. Operates only on one given region. If you need to analyze many regions, use the plural version of this function.\nget_ssm_by_regions: Return maf data with variants in a single given region. Operates only on one given region. This function is really just a wrapper for the singular version but works on many given regions.\nget_ssm_by_samples: Return maf data (both coding and non-coding mutations) for a given set of samples. This will return maf data for only the specified sample even if multiple sample exist for a given patient.\nid_ease: Internal function that converts vector of sample ids into data frame with metadata and vice versa. Used internally and is not really meant for standalone use.\nprocess_regions: Helper function that will harmonize genomic regions specified as character vectors or data frame. Returns list with two objects, regions as a vector and in bed format.\nregion_to_chunks: Helper function that will separate a chromosome region specified in UCSC format into individual chunks of chromosome, start, and end.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "concepts/GAMBLR_family.html",
    "href": "concepts/GAMBLR_family.html",
    "title": "GAMBLR family of packages",
    "section": "",
    "text": "GAMBLR.data is the first and most basic member of the GAMBLR family of packages. It is mostly serving a purpose of storing the bundled data helpful for genomic analysis of B-cell neoplasms in GAMBLR, and also contains small basic functions serving as API to retreive this data.\nSome of the bundled data is versioned and it keeps being updated. This insludes, but is not limited to, regions targeted by aSHM (new regions are being added as they are identified), curated list of lymphoma genes, somatic mutations hotsposts etc. Conveniently for the user, unless they request the specific version of the data, the most recent and up-to-date version is used by default.\nThe GAMBLR family includes:\n\nGAMBLR.data - this package\nGAMBLR.helpers - a set of low-level functions for data operation\nGAMBLR.utils - higher level set of functions to operate on genomic data\nGAMBLR.viz - set of functions used mostly for visualizations\nGAMBLR.results - used for access of the full data in GAMBL project. Only available for the members of the Morin Lab and requires access to GSC, but can also be run locally once properly configured and synced.\n\nThis diagram illustrates a simplified way of dependency relationship for different packages in the GAMBLR.family:\n\n\n\n\nflowchart LR\n  A(\"GAMBLR.data\") --&gt; B(\"GAMBLR.helpers\")\n  B --&gt; C(\"GAMBLR.utils\")\n  C --&gt; D(\"GAMBLR.viz\")\n  D --&gt; E{\"Morin Lab member?\"}\n  E -- YES --&gt; F(\"GAMBLR.results\")\n  E -- NO --&gt; A\n\n\n\n\n\nAll dependencies should be installed for you just like for any other R package. If not, please report the issue in the appropriate GitHub repo.\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "This is a quick tour of some basic commands and usage patterns, just to get you started.\n\n#Load packages\nlibrary(GAMBLR.data)\nlibrary(tidyverse)\n\nThis tutorial explores how to retrieve different data types bundled withing GAMBLR.data. Commonly, such GAMBLR functions are prefixed with get_. These functions are readily available for returning data of different types: Simple Somatic Mutations (SSM), Copy Number (CN) segments and Structural Variants (SV). This resource explores commonly occurring arguments across different functions, best-practices and recommendations in the scope of retrieving data.\n\n\nFirst, lets start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n#Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nNow that we have the metadata, it can illustrate what are the expected column names and their format:\n\nstr(metadata$all)\n\ntibble [4,785 × 27] (S3: tbl_df/tbl/data.frame)\n $ sample_id           : chr [1:4785] \"00-14595_tumorA\" \"00-14595_tumorB\" \"00-14595_tumorC\" \"00-14595_tumorD\" ...\n $ patient_id          : chr [1:4785] \"00-14595\" \"00-14595\" \"00-14595\" \"00-14595\" ...\n $ pathology           : chr [1:4785] \"COMFL\" \"COMFL\" \"DLBCL\" \"FL\" ...\n $ seq_type            : chr [1:4785] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ genome_build        : chr [1:4785] \"grch37\" \"grch37\" \"grch37\" \"grch37\" ...\n $ pairing_status      : chr [1:4785] \"matched\" \"matched\" \"matched\" \"matched\" ...\n $ Tumor_Sample_Barcode: chr [1:4785] \"00-14595_tumorA\" \"00-14595_tumorB\" \"00-14595_tumorC\" \"00-14595_tumorD\" ...\n $ age_group           : chr [1:4785] \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ compression         : chr [1:4785] \"bam\" \"cram\" \"cram\" \"cram\" ...\n $ bam_available       : logi [1:4785] TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ pathology_rank      : num [1:4785] 13 13 19 15 19 19 15 27 19 19 ...\n $ cohort              : chr [1:4785] \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" ...\n $ COO_consensus       : chr [1:4785] \"GCB\" \"GCB\" \"GCB\" \"GCB\" ...\n $ DHITsig_consensus   : chr [1:4785] \"DHITsigNeg\" \"DHITsigPos\" \"DHITsig-IND\" \"DHITsig-IND\" ...\n $ EBV_status_inf      : chr [1:4785] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:4785] \"FFPE\" \"FFPE\" \"FFPE\" \"FFPE\" ...\n $ fl_grade            : chr [1:4785] NA NA NA NA ...\n $ hiv_status          : chr [1:4785] \"UNKNOWN\" \"UNKNOWN\" \"UNKNOWN\" \"UNKNOWN\" ...\n $ lymphgen            : Factor w/ 12 levels \"EZB\",\"EZB-COMP\",..: 1 1 1 1 12 7 1 12 NA 1 ...\n $ lymphgen_cnv_noA53  : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_no_cnv     : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_with_cnv   : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_wright     : chr [1:4785] NA NA NA NA ...\n $ molecular_BL        : chr [1:4785] NA NA NA NA ...\n $ normal_sample_id    : chr [1:4785] \"00-14595_normal\" \"00-14595_normal\" \"00-14595_normal\" \"00-14595_normal\" ...\n $ sex                 : chr [1:4785] \"F\" \"F\" \"F\" \"F\" ...\n $ time_point          : chr [1:4785] \"A\" \"B\" \"C\" \"D\" ...\n\n\nWe can now use the metadata as we wish, for example see what pathologies are available and do any sort of subsetting.\n\n#We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n#Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\n#Quick sanity check\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nBased on the information available to the user, application, or downstream analysis, there are multiple ways to retrieve SSM data. For example, if the user knows the sample ID and is only interested in looking at SSM results for that particular sample, one can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. The user can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, the user can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in MAF-like format. If the user have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n#How manny mutations do we get back?\ndim(ssm_sample)\n\n[1] 22137    45\n\n#What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n#What variants are the available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n#How manny mutations do we get back?\ndim(ssm_meta)\n\n[1] 22137    45\n\n#What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n#What variants are the available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nReturnng maf data for thousands or hundreds of files can be potentially creating memory or space issues to store the Rsession if you are using old-day R editors like RStudio. To facilitate this, you can optionally request the SSM to be returned just for a small number of specific genes with the argument these_genes:\n\n# Only look at specific gene(s)\nmy_genes &lt;- c(\"MYC\")\n\nssm_myc &lt;- get_ssm_by_samples(\n    these_sample_ids = my_sample_id,\n    these_genes = my_genes\n)\n\nssm_myc %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nSimilarly, do decrease the burden of handling large maf data, it is also possible to dictate what MAF columns we want back. To do this, call the function with the maf_col argument and provide vector of the columns of interest. Here, we are requesting SSM calls for only a small set of columns. It is also important to note that this will require setting of another argument basic_columns to FALSE as this argument takes precedence of all other arguments that control output columns and returns first 45 columns of standard maf.\n\n# Define the column names\nmy_columns &lt;- c(\n    \"Hugo_Symbol\",\n    \"Chromosome\",\n    \"Start_Position\",\n    \"End_Position\",\n    \"Tumor_Sample_Barcode\",\n    \"Variant_Classification\"\n)\n\n# Since we don provide neither of arguments that restrict to specific\n# samples, we expect the return to contain data from all samples in the bundled\n# data\nssm_col &lt;- get_ssm_by_samples(\n    these_genes = my_genes,\n    maf_col = my_columns,\n    basic_columns = FALSE\n)\n\n# What are the dimensions for the capture SSM calls?\ndim(ssm_col)\n\n[1] 3884    6\n\n# What are the columns in the output?\ncolnames(ssm_col)\n\n[1] \"Hugo_Symbol\"            \"Chromosome\"             \"Start_Position\"        \n[4] \"End_Position\"           \"Tumor_Sample_Barcode\"   \"Variant_Classification\"\n\n\n\n\n\nOften many downstream tools can only work on one or the other genome buid, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projection. The default output is always wuth respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\nAs we did not specify any sample id, metadata, or gene to the above call, it by default returned the data for all samples available in the GAMBR.data and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section we are exploring the different ways you can return the maf data for a specific region (or regions) of interest.\n\n\nIf you are only looking at one specific position, you can take advantage of the get_ssm_by_region() function:\n\n# MYC region (grch37)\nmyc_region &lt;- \"8:128747680-128753674\"\n\n# Get all SSMs that are residing in the defined MYC region\nmyc_ssm &lt;- get_ssm_by_region(region = myc_region)\n\nmyc_ssm %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nWe can also specify the coordinates we are interested in using the chromosome, qstart, and qend arguments:\n\n# Get all SSMs that are residing in the defined MYC region\nmyc_ssm_arg &lt;- get_ssm_by_region(\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674\n)\n\nmyc_ssm_arg %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\nLet us also confirm that the returned maf is the same we get back with the region argument:\n\nidentical(\n    myc_ssm,\n    myc_ssm_arg\n)\n\n[1] TRUE\n\n\n\n\n\nIf you are working with massive maf data containing many variants and have already imported it to R, or using the maf data not coming with this package, you can still take advantage of this function and use the pre-loaded maf. This function will still subset it to the desired regions. To do so, specify the MAF of interest with maf_data:\n\ndohh2_myc_ssm &lt;- get_ssm_by_region(\n    maf_data = ssm_sample,\n    region = myc_region\n)\n\nWhile we are on it, is it generating the same output as when we ask for SSM to be returned for a specific gene with get_ssm_by_samples()?\n\nidentical(\n    ssm_myc,\n    dohh2_myc_ssm\n)\n\n[1] TRUE\n\n\nYes, indeed - the both outputs are identical again.\n\n\n\nThis function also has a streamlined option available. If set to TRUE, only two columns are kept in the returned MAF (Start_Position and Tumour_Sample_Barcode). In this example, we are extending the coordinates to encapsulate the whole p-arm of chromosome 1. Note, since we are requesting hg38 calls, we have to add the chr prefix for the specified chromosome. Don’t remember the coordinates? Likely, the GAMBLR.data provides the coordinates for chromosome arms in both projections!\n\ncoord &lt;- chromosome_arms_hg38 %&gt;%\n    filter(arm == \"p\", chromosome == \"chr1\")\n\nstreamlined_ssm &lt;- get_ssm_by_region(\n    chromosome = coord$chromosome,\n    qstart = coord$start,\n    qend = coord$end,\n    streamlined = TRUE,\n    projection = \"hg38\"\n)\n\n#What columns are kept with streamlined = TRUE?\ncolnames(streamlined_ssm)\n\n[1] \"Start_Position\"       \"Tumor_Sample_Barcode\"\n\n#How many variants do we find within the specified region?\nnrow(streamlined_ssm)\n\n[1] 7749\n\n\n\n\n\nSimilarly to other get_ssm functions, we can also call get_ssm_by_region with either these_sample_ids or these_samples_metadata to restrict the return to specific sample IDs. In this example, we first call the function with these_sample_ids = \"DOHH-2\" and then with these_samples_metadata giving the function a metadata that has been subset to the same sample ID.\n\ndohh2_region_sample &lt;- get_ssm_by_region(\n    these_sample_ids = my_sample_id,\n    region = myc_region\n)\n\ndohh2_region_metadata &lt;- get_ssm_by_region(\n    these_samples_metadata = metadata$dohh2,\n    region = myc_region\n)\n\nWe can also see that both approaches generate identical output:\n\n#Are the two returned data frames identical?\nidentical(\n    dohh2_region_sample,\n    dohh2_region_metadata\n)\n\n[1] TRUE\n\n\n\n\n\nFor multiple regions, refer to the plural version, get_ssm_by_regions. In this example we will return SSM calls for all aSHM regions associated with PAX5 across all available samples. With this multiple-region-version of this function we also get the region name added to the returned data frame and there are a couple of different ways this can be done. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns. Don’t know coordinates of aSHM at PAX5? GAMBLR.data got you covered!\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- grch37_ashm_regions %&gt;%\n    filter(gene == ashm_gene) %&gt;%\n    rename(\n        chromosome = chr_name,\n        start = hg19_start,\n        end = hg19_end\n    ) %&gt;%\n    mutate(\n        name = paste0(gene, \"_\", region)\n    )\n\n#Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    regions_bed = regions,\n    use_name_column = TRUE,\n    streamlined = TRUE\n)\n\nhead(ashm_ssm)\n\n# A tibble: 6 × 3\n     start sample_id region_name  \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        \n1 37025887 01-20260T PAX5_intron-1\n2 37024351 04-24937T PAX5_intron-1\n3 37025246 04-24937T PAX5_intron-1\n4 37025268 04-24937T PAX5_intron-1\n5 37025300 04-24937T PAX5_intron-1\n6 37025820 04-24937T PAX5_intron-1\n\n\n\n\n\nYou can instead specify regions as a vector of characters (regions_list) instead of using a bed file. In this case, the function will not accept a fourth element for naming the returned regions. If so, the function defaults to using the specified regions instead.\n\nssm_region_list &lt;- get_ssm_by_regions(\n    regions_list = c(\n        \"chr9:37023396-37027663\",\n        \"chr9:37029849-37037154\",\n        \"chr9:37369209-37372160\"\n    ),\n    streamlined = TRUE\n)\n\nhead(ssm_region_list)\n\n# A tibble: 6 × 3\n     start sample_id region_name           \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;                 \n1 37025887 01-20260T chr9:37023396-37027663\n2 37024351 04-24937T chr9:37023396-37027663\n3 37025246 04-24937T chr9:37023396-37027663\n4 37025268 04-24937T chr9:37023396-37027663\n5 37025300 04-24937T chr9:37023396-37027663\n6 37025820 04-24937T chr9:37023396-37027663\n\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not called, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# Limit_cohort\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    limit_cohort = \"DLBCL_cell_lines\"\n)\n\ndim(dlbcl_cell_lines)\n\n[1] 1616   47\n\n\nInstead, we can just exclude a group of samples by using the exclude_cohort argument:\n\n#Exclude_cohort\nno_dlbcl_cell_lines &lt;- get_coding_ssm(\n    exclude_cohort =  \"DLBCL_cell_lines\"\n)\ndim(no_dlbcl_cell_lines)\n\n[1] 63461    47"
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "href": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "First, lets start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n#Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nNow that we have the metadata, it can illustrate what are the expected column names and their format:\n\nstr(metadata$all)\n\ntibble [4,785 × 27] (S3: tbl_df/tbl/data.frame)\n $ sample_id           : chr [1:4785] \"00-14595_tumorA\" \"00-14595_tumorB\" \"00-14595_tumorC\" \"00-14595_tumorD\" ...\n $ patient_id          : chr [1:4785] \"00-14595\" \"00-14595\" \"00-14595\" \"00-14595\" ...\n $ pathology           : chr [1:4785] \"COMFL\" \"COMFL\" \"DLBCL\" \"FL\" ...\n $ seq_type            : chr [1:4785] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ genome_build        : chr [1:4785] \"grch37\" \"grch37\" \"grch37\" \"grch37\" ...\n $ pairing_status      : chr [1:4785] \"matched\" \"matched\" \"matched\" \"matched\" ...\n $ Tumor_Sample_Barcode: chr [1:4785] \"00-14595_tumorA\" \"00-14595_tumorB\" \"00-14595_tumorC\" \"00-14595_tumorD\" ...\n $ age_group           : chr [1:4785] \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ compression         : chr [1:4785] \"bam\" \"cram\" \"cram\" \"cram\" ...\n $ bam_available       : logi [1:4785] TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ pathology_rank      : num [1:4785] 13 13 19 15 19 19 15 27 19 19 ...\n $ cohort              : chr [1:4785] \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" \"DLBCL_LSARP_Trios\" ...\n $ COO_consensus       : chr [1:4785] \"GCB\" \"GCB\" \"GCB\" \"GCB\" ...\n $ DHITsig_consensus   : chr [1:4785] \"DHITsigNeg\" \"DHITsigPos\" \"DHITsig-IND\" \"DHITsig-IND\" ...\n $ EBV_status_inf      : chr [1:4785] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:4785] \"FFPE\" \"FFPE\" \"FFPE\" \"FFPE\" ...\n $ fl_grade            : chr [1:4785] NA NA NA NA ...\n $ hiv_status          : chr [1:4785] \"UNKNOWN\" \"UNKNOWN\" \"UNKNOWN\" \"UNKNOWN\" ...\n $ lymphgen            : Factor w/ 12 levels \"EZB\",\"EZB-COMP\",..: 1 1 1 1 12 7 1 12 NA 1 ...\n $ lymphgen_cnv_noA53  : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_no_cnv     : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_with_cnv   : chr [1:4785] \"EZB\" \"EZB\" \"EZB\" \"EZB\" ...\n $ lymphgen_wright     : chr [1:4785] NA NA NA NA ...\n $ molecular_BL        : chr [1:4785] NA NA NA NA ...\n $ normal_sample_id    : chr [1:4785] \"00-14595_normal\" \"00-14595_normal\" \"00-14595_normal\" \"00-14595_normal\" ...\n $ sex                 : chr [1:4785] \"F\" \"F\" \"F\" \"F\" ...\n $ time_point          : chr [1:4785] \"A\" \"B\" \"C\" \"D\" ...\n\n\nWe can now use the metadata as we wish, for example see what pathologies are available and do any sort of subsetting.\n\n#We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n#Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\n#Quick sanity check\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )"
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "href": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "Based on the information available to the user, application, or downstream analysis, there are multiple ways to retrieve SSM data. For example, if the user knows the sample ID and is only interested in looking at SSM results for that particular sample, one can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. The user can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, the user can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in MAF-like format. If the user have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n#How manny mutations do we get back?\ndim(ssm_sample)\n\n[1] 22137    45\n\n#What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n#What variants are the available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)+\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n#How manny mutations do we get back?\ndim(ssm_meta)\n\n[1] 22137    45\n\n#What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                  \n\n#What variants are the available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nReturnng maf data for thousands or hundreds of files can be potentially creating memory or space issues to store the Rsession if you are using old-day R editors like RStudio. To facilitate this, you can optionally request the SSM to be returned just for a small number of specific genes with the argument these_genes:\n\n# Only look at specific gene(s)\nmy_genes &lt;- c(\"MYC\")\n\nssm_myc &lt;- get_ssm_by_samples(\n    these_sample_ids = my_sample_id,\n    these_genes = my_genes\n)\n\nssm_myc %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nSimilarly, do decrease the burden of handling large maf data, it is also possible to dictate what MAF columns we want back. To do this, call the function with the maf_col argument and provide vector of the columns of interest. Here, we are requesting SSM calls for only a small set of columns. It is also important to note that this will require setting of another argument basic_columns to FALSE as this argument takes precedence of all other arguments that control output columns and returns first 45 columns of standard maf.\n\n# Define the column names\nmy_columns &lt;- c(\n    \"Hugo_Symbol\",\n    \"Chromosome\",\n    \"Start_Position\",\n    \"End_Position\",\n    \"Tumor_Sample_Barcode\",\n    \"Variant_Classification\"\n)\n\n# Since we don provide neither of arguments that restrict to specific\n# samples, we expect the return to contain data from all samples in the bundled\n# data\nssm_col &lt;- get_ssm_by_samples(\n    these_genes = my_genes,\n    maf_col = my_columns,\n    basic_columns = FALSE\n)\n\n# What are the dimensions for the capture SSM calls?\ndim(ssm_col)\n\n[1] 3884    6\n\n# What are the columns in the output?\ncolnames(ssm_col)\n\n[1] \"Hugo_Symbol\"            \"Chromosome\"             \"Start_Position\"        \n[4] \"End_Position\"           \"Tumor_Sample_Barcode\"   \"Variant_Classification\"\n\n\n\n\n\nOften many downstream tools can only work on one or the other genome buid, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projection. The default output is always wuth respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\nAs we did not specify any sample id, metadata, or gene to the above call, it by default returned the data for all samples available in the GAMBR.data and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section we are exploring the different ways you can return the maf data for a specific region (or regions) of interest.\n\n\nIf you are only looking at one specific position, you can take advantage of the get_ssm_by_region() function:\n\n# MYC region (grch37)\nmyc_region &lt;- \"8:128747680-128753674\"\n\n# Get all SSMs that are residing in the defined MYC region\nmyc_ssm &lt;- get_ssm_by_region(region = myc_region)\n\nmyc_ssm %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\nWe can also specify the coordinates we are interested in using the chromosome, qstart, and qend arguments:\n\n# Get all SSMs that are residing in the defined MYC region\nmyc_ssm_arg &lt;- get_ssm_by_region(\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674\n)\n\nmyc_ssm_arg %&gt;%\n    count(Hugo_Symbol) %&gt;%\n    ggplot(\n        aes(\n            x = Hugo_Symbol,\n            y = n,\n            fill = Hugo_Symbol\n        )\n    ) +\n    geom_bar(stat = \"identity\")\n\n\n\n\nLet us also confirm that the returned maf is the same we get back with the region argument:\n\nidentical(\n    myc_ssm,\n    myc_ssm_arg\n)\n\n[1] TRUE\n\n\n\n\n\nIf you are working with massive maf data containing many variants and have already imported it to R, or using the maf data not coming with this package, you can still take advantage of this function and use the pre-loaded maf. This function will still subset it to the desired regions. To do so, specify the MAF of interest with maf_data:\n\ndohh2_myc_ssm &lt;- get_ssm_by_region(\n    maf_data = ssm_sample,\n    region = myc_region\n)\n\nWhile we are on it, is it generating the same output as when we ask for SSM to be returned for a specific gene with get_ssm_by_samples()?\n\nidentical(\n    ssm_myc,\n    dohh2_myc_ssm\n)\n\n[1] TRUE\n\n\nYes, indeed - the both outputs are identical again.\n\n\n\nThis function also has a streamlined option available. If set to TRUE, only two columns are kept in the returned MAF (Start_Position and Tumour_Sample_Barcode). In this example, we are extending the coordinates to encapsulate the whole p-arm of chromosome 1. Note, since we are requesting hg38 calls, we have to add the chr prefix for the specified chromosome. Don’t remember the coordinates? Likely, the GAMBLR.data provides the coordinates for chromosome arms in both projections!\n\ncoord &lt;- chromosome_arms_hg38 %&gt;%\n    filter(arm == \"p\", chromosome == \"chr1\")\n\nstreamlined_ssm &lt;- get_ssm_by_region(\n    chromosome = coord$chromosome,\n    qstart = coord$start,\n    qend = coord$end,\n    streamlined = TRUE,\n    projection = \"hg38\"\n)\n\n#What columns are kept with streamlined = TRUE?\ncolnames(streamlined_ssm)\n\n[1] \"Start_Position\"       \"Tumor_Sample_Barcode\"\n\n#How many variants do we find within the specified region?\nnrow(streamlined_ssm)\n\n[1] 7749\n\n\n\n\n\nSimilarly to other get_ssm functions, we can also call get_ssm_by_region with either these_sample_ids or these_samples_metadata to restrict the return to specific sample IDs. In this example, we first call the function with these_sample_ids = \"DOHH-2\" and then with these_samples_metadata giving the function a metadata that has been subset to the same sample ID.\n\ndohh2_region_sample &lt;- get_ssm_by_region(\n    these_sample_ids = my_sample_id,\n    region = myc_region\n)\n\ndohh2_region_metadata &lt;- get_ssm_by_region(\n    these_samples_metadata = metadata$dohh2,\n    region = myc_region\n)\n\nWe can also see that both approaches generate identical output:\n\n#Are the two returned data frames identical?\nidentical(\n    dohh2_region_sample,\n    dohh2_region_metadata\n)\n\n[1] TRUE\n\n\n\n\n\nFor multiple regions, refer to the plural version, get_ssm_by_regions. In this example we will return SSM calls for all aSHM regions associated with PAX5 across all available samples. With this multiple-region-version of this function we also get the region name added to the returned data frame and there are a couple of different ways this can be done. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns. Don’t know coordinates of aSHM at PAX5? GAMBLR.data got you covered!\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- grch37_ashm_regions %&gt;%\n    filter(gene == ashm_gene) %&gt;%\n    rename(\n        chromosome = chr_name,\n        start = hg19_start,\n        end = hg19_end\n    ) %&gt;%\n    mutate(\n        name = paste0(gene, \"_\", region)\n    )\n\n#Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    regions_bed = regions,\n    use_name_column = TRUE,\n    streamlined = TRUE\n)\n\nhead(ashm_ssm)\n\n# A tibble: 6 × 3\n     start sample_id region_name  \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        \n1 37025887 01-20260T PAX5_intron-1\n2 37024351 04-24937T PAX5_intron-1\n3 37025246 04-24937T PAX5_intron-1\n4 37025268 04-24937T PAX5_intron-1\n5 37025300 04-24937T PAX5_intron-1\n6 37025820 04-24937T PAX5_intron-1\n\n\n\n\n\nYou can instead specify regions as a vector of characters (regions_list) instead of using a bed file. In this case, the function will not accept a fourth element for naming the returned regions. If so, the function defaults to using the specified regions instead.\n\nssm_region_list &lt;- get_ssm_by_regions(\n    regions_list = c(\n        \"chr9:37023396-37027663\",\n        \"chr9:37029849-37037154\",\n        \"chr9:37369209-37372160\"\n    ),\n    streamlined = TRUE\n)\n\nhead(ssm_region_list)\n\n# A tibble: 6 × 3\n     start sample_id region_name           \n     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;                 \n1 37025887 01-20260T chr9:37023396-37027663\n2 37024351 04-24937T chr9:37023396-37027663\n3 37025246 04-24937T chr9:37023396-37027663\n4 37025268 04-24937T chr9:37023396-37027663\n5 37025300 04-24937T chr9:37023396-37027663\n6 37025820 04-24937T chr9:37023396-37027663\n\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not called, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# Limit_cohort\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    limit_cohort = \"DLBCL_cell_lines\"\n)\n\ndim(dlbcl_cell_lines)\n\n[1] 1616   47\n\n\nInstead, we can just exclude a group of samples by using the exclude_cohort argument:\n\n#Exclude_cohort\nno_dlbcl_cell_lines &lt;- get_coding_ssm(\n    exclude_cohort =  \"DLBCL_cell_lines\"\n)\ndim(no_dlbcl_cell_lines)\n\n[1] 63461    47"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAMBLR.data",
    "section": "",
    "text": "Why use GAMBLR.data?\n  \n  \n    \n     How to install?\n  \n  \n    \n     How to use?\n  \n  \n    \n     Release notes\n  \n  \n    \n     GitHub"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "GAMBLR.data",
    "section": "Install",
    "text": "Install\nWe recommend installing the package directly from GitHub (requires devtools dependency).\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n1)\n\n1\n\nInstall GAMBLR.data directly from GitHub along with all bundled data.\n\n\n\n\n\nShow quickstart"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "GAMBLR.data",
    "section": "Quickstart",
    "text": "Quickstart\nThe quick and easy way to get started is to make sure the devtools dependency is installed, then install the GAMBLR.data and run a simple function that returns metadata to confirm successful setup:\n# Verify devtools is installed\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\n# Install GAMBLR.data\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n)\n\n# Confirm successful setup\nget_gambl_metadata() # returns simple metadata data frame\nget_coding_ssm() # returns data frame in maf formatting with somatic variants"
  },
  {
    "objectID": "index.html#installation-for-developers",
    "href": "index.html#installation-for-developers",
    "title": "GAMBLR.data",
    "section": "Installation for developers",
    "text": "Installation for developers\nThe easiest way to obtain and contribute to GAMBLR.data is to do this via cloning the repository\ncd\ngit clone git@github.com:morinlab/GAMBLR.data.git\nIn your R editor of choice (which is hopefully VS Code now), set your working directory to the place you just cloned the repo.\nsetwd(\"~/GAMBLR.data\")\nInstall the package in R by running the following command (requires the devtools package)\ndevtools::install()\nGAMBLR.data is a free open-source package, but the Master branch is protected. We welcome contributions (pull request, bug report, feature request, PR review) from all levels of users. All commits must be submitted via pull request on a branch. Please refer to the GitHub documentation for details on how to do pull request."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "why.html",
    "href": "why.html",
    "title": "Why GAMBLR.data?",
    "section": "",
    "text": "GAMBLR.data is an open-source portable R library.\nIf you’ve had issues with importing genomic data from large-scale lymphoma studies, need to work with standardized data used for analysis of somatic variants, find yourself translating between different genome build systems, or just want a great great comprehensive resource of genomic data in B-cell lymphomas, GAMBLR.data is for you.\nGAMBLR stands for Genomic Analysis of Mature B-cell Lymphomas in R, and is part of the family of R packages for lymphoma cancer research developed in the Morin Lab at the Simon Fraser University."
  },
  {
    "objectID": "why.html#gamblr-family",
    "href": "why.html#gamblr-family",
    "title": "Why GAMBLR.data?",
    "section": "GAMBLR family",
    "text": "GAMBLR family\nGAMBLR.data is part of a larger family of R tools for the analysis of lymphoma genomic data.\nIt is designed to mainly serve as a storeage of bundled data resources and works well with other tools in the GAMBLR family. We continue to bundle more data available through this package, as well as improve it’s functionality.\nFor more details, please refer to the GAMBLR family section."
  },
  {
    "objectID": "why.html#local-experience",
    "href": "why.html#local-experience",
    "title": "Why GAMBLR.data?",
    "section": "Local experience",
    "text": "Local experience\nThe data bundled with the GAMBLR.data is immediately available upon package installation and does not require internet coonection or ssh access to GSC resources. It can run anywhere the R is available without restrictions and limitations."
  },
  {
    "objectID": "why.html#use-cases",
    "href": "why.html#use-cases",
    "title": "Why GAMBLR.data?",
    "section": "Use cases",
    "text": "Use cases\nYou can use GAMBLR.data at any stage of your lymphoma data analysis workflow.\nGAMBLR.data helps with:\n\none-stop shop to obtain somatic variants from BL, DLBCL, and FL cases (studies by Thomas et al, Dreval et al, Schmitz et al, Chapuy et al, Reddy et al.) and variant calls from some DLBCL cell lines.\nQC metrics from major WGS and WEX studies of B-cell lymphomas (as reported in Dreval et al.)\nCurated lists of lymphoma genes for all major pathologies\nCurated list of regions targeted by aSHM in B-cell lymphomas\nCoordinates of chromosome arms in both genome projections\nGene coordinates in both genome projection\nCoordinates of oncogenes and SV partners in both genome projections\nHotspot regions for selected genes in both projections\nOther resources\n\nFor more details, please refer to the bundled data section."
  },
  {
    "objectID": "why.html#community",
    "href": "why.html#community",
    "title": "Why GAMBLR.data?",
    "section": "Community",
    "text": "Community\nCommunity discussions primarily happen through issue submission on GitHub."
  },
  {
    "objectID": "why.html#getting-started",
    "href": "why.html#getting-started",
    "title": "Why GAMBLR.data?",
    "section": "Getting started",
    "text": "Getting started\nIf you’re interested in trying GAMBLR.data we recommend the getting started tutorial."
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installation",
    "section": "",
    "text": "Installation\nWe recommend installing the package directly from GitHub (requires devtools dependency).\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\ndevtools::install_github(\n    \"morinlab/GAMBLR.data\",\n    repos = BiocManager::repositories()\n)\nYou can confirm successful installation by running some of the easy and most popular commands:\nget_gambl_metadata() # returns simple metadata data frame\nget_coding_ssm() # returns data frame in maf formatting with somatic variants\n\n\n\n\n Back to top"
  },
  {
    "objectID": "concepts/glossary.html",
    "href": "concepts/glossary.html",
    "title": "GAMBLR.data glossary",
    "section": "",
    "text": "There are several key concepts underlying the logic behind the GAMBLR.data package. The main terms are:\n\nprojection: This is a coordinate system defining the relationship with genome build and chromosome prefixing. The main projections supported throughout GAMBLR.data are grch37 and hg38. The grch37 projection is always not prefixed and is in relation to the coordinate system of the hg19 genome build. In contrast, the hg38 is always chr-prefixed and is in relation to the coordinate system of the hg38 genome build. As GAMBL itself and the data bundled and available through this package represents a large collection of samples sequenced both locally and externally, there is always a difficulty associated with proper handling of prefixes, different custom contigs and their lengths in the fasta reference, coordinates, and other distinctions complicating the direct comparison and comprehensive data analysis. This is handled internally and is always availabe in one or the other projection regardless of initial genome build to which the sample was aligned to.\nmetadata: This is a data frame with a set of minimal required columns such as patient_id, Tumor_Sample_Barcode, sample_id, seq_type, sex, cohort, and pathology. The columns like sex and cohort can contain NA calues but must be present in the metadata. The main purpose of this data frame is to provide a structure for the metadata that is always expected to be available and provides linkage between unique sample identifiers and associated basic metadata values. The columns Tumor_Sample_Barcode and sample_id are expected to contain duplicate values, but are required to be present for direct operation on the outputs of different upstream tools.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "resources/bundled_data.html",
    "href": "resources/bundled_data.html",
    "title": "Data bunded with GAMBLR.data",
    "section": "",
    "text": "The GAMBLR.data comes with many different bundled data objects that can be systematically organized in the following categories:"
  },
  {
    "objectID": "resources/bundled_data.html#somatic-variants",
    "href": "resources/bundled_data.html#somatic-variants",
    "title": "Data bunded with GAMBLR.data",
    "section": "Somatic variants",
    "text": "Somatic variants\n\nsample_data A list of data frames containing the metadata, simple somatic, copy number, and structural variants collected together from the supplemental tables of large sequencing studies of B-cell lymphomas."
  },
  {
    "objectID": "resources/bundled_data.html#curated-gene-lists",
    "href": "resources/bundled_data.html#curated-gene-lists",
    "title": "Data bunded with GAMBLR.data",
    "section": "Curated gene lists",
    "text": "Curated gene lists\n\ngene_blacklist A tibble with gene symbols (Hugo) that falls within blacklisted regions of the genome. The genes in this data object represent common sequencing artefacts and are discarded during the data analysis.\nlymphoma_genes A data frame with manually curated set of genes commonly mutated in lymphomas with associated TRUE/FALSE columns annotating lymphoma type(s) where the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_bl_v0.1 A data frame with manually curated set of genes commonly mutated in BL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred directly by it’s version number.\nlymphoma_genes_bl_v_latest A data frame with manually curated set of genes commonly mutated in BL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_comprehensive A data frame with the curated list of genes reported as significantly mutated in the large lymphoma studies. Both Ensembl ID and Hugo Symbol are serving as gene identifiers. This data contains annotation for the studies by Chapuy, Reddy, Wright (LymphGen), Lacy, as well as annotation of being curated, reported as SMG in other_studies, or being aSHM target.\nlymphoma_genes_dlbcl_v0.1 A data frame with manually curated set of genes commonly mutated in DLBCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred directly by it’s version number.\nlymphoma_genes_dlbcl_v_latest A data frame with manually curated set of genes commonly mutated in DLBCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list.\nlymphoma_genes_lymphoma_genes_v0.0 Legacy version of the curated list of genes significantly mutated in lymphomas. Bundled here for backwards compatibility and can be referred directly by it’s version number.\nlymphoma_genes_mcl_v0.1 A data frame with manually curated set of genes commonly mutated in MCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This is the versioned data and can be referred directly by it’s version number.\nlymphoma_genes_mcl_v_latest A data frame with manually curated set of genes commonly mutated in MCL with associated TRUE/FALSE columns annotating whether the particular mutations are present. This object by default always represents the most recent version of the curated list."
  },
  {
    "objectID": "resources/bundled_data.html#coordinate-based-resources",
    "href": "resources/bundled_data.html#coordinate-based-resources",
    "title": "Data bunded with GAMBLR.data",
    "section": "Coordinate-based resources",
    "text": "Coordinate-based resources\n\nchromosome_arms_grch37: A data frame with the chromosome arm coordinates in respect to grch37 projection.\nchromosome_arms_hg38 A data frame with the chromosome arm coordinates in respect to hg38.\ngrch37_gene_coordinates All gene coordinates in respect to grch37. Contains both Ensembl ID and Hugo Symbol as identifier.\ngrch37_lymphoma_genes_bed Coordinates in respect to grch37 for the genes commonly associated with B-cell lymphomas.\ngrch37_oncogene A data frame with the coordinates of lymphoma oncogenes relative to the grch37. Used in mapping of the breakpoint coordinates.\ngrch37_partners Translocation partners for oncogenes with coordinates in respect to grch37.\nhg38_gene_coordinates All gene coordinates in respect to hg38. Contains both Ensembl ID and Hugo Symbol as identifier.\nhg38_lymphoma_genes_bed Coordinates in respect to hg38 for the genes commonly associated with B-cell lymphomas.\nhg38_oncogene A data frame with the coordinates of lymphoma oncogenes relative to the hg38. Used in mapping of the breakpoint coordinates.\nhg38_partners Translocation partners for oncogenes with coordinates in respect to hg38.\ngrch37_all_gene_coordinates Protein-coding gene coordinates in respect to grch37. Contains both Ensembl ID and Hugo Symbol as identifier. Mainly here for backwards compatibility with earlier GAMBLR versions.\nhotspot_regions_grch37 Mutation hotspot regions in respect to grch37.\nhotspot_regions_hg38 Mutation hotspot regions in respect to hg38.\ntarget_regions_grch37 A data frame with coordinates of the target regions of the genome representing the whole exome sequencing panel. This is Agilent V5 (no UTR) with respect to grch37.\ntarget_regions_hg38 A data frame with coordinates of the target regions of the genome representing the whole exome sequencing panel. This is Agilent V5 (no UTR) with respect to hg38."
  },
  {
    "objectID": "resources/bundled_data.html#ashm-regions",
    "href": "resources/bundled_data.html#ashm-regions",
    "title": "Data bunded with GAMBLR.data",
    "section": "aSHM regions",
    "text": "aSHM regions\n\ngrch37_ashm_regions Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This object always by default refers to the most recent version of the aSHM regions.\nhg38_ashm_regions Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This object always by default refers to the most recent version of the aSHM regions.\nsomatic_hypermutation_locations_GRCh37_v0.0 Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.1 Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.2 Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v0.3 Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh37_v_latest Aberrant somatic hypermutation (aSHM) regions in respect to grch37. This is an alias for the latest version of this data.\nsomatic_hypermutation_locations_GRCh38_v0.0 Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.1 Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.2 Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v0.3 Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This is the versioned data and can be referred directly by it’s version number.\nsomatic_hypermutation_locations_GRCh38_v_latest Aberrant somatic hypermutation (aSHM) regions in respect to hg38. This is an alias for the latest version of this data."
  },
  {
    "objectID": "resources/bundled_data.html#other-resources",
    "href": "resources/bundled_data.html#other-resources",
    "title": "Data bunded with GAMBLR.data",
    "section": "Other resources",
    "text": "Other resources\n\ncolour_codes A data frame with colour codes (HEX) arranged into different categories, groups.\ndhitsig_genes_with_weights A data frame with double hit signature genes (both as ensembl IDs and Hugo symbols) and importance scores.\ngambl_metadata A data frame with metadata for a collection of GAMBL samples. This represents a collection of whole genome, exome, targeted, RNA, and PrometION sequencing samples available as a data set known as GAMBL. This object rather serves an FYI purpose as not all samples listed here are published and bundled with GAMBLR.data.\nhgnc2pfam.df A dataset containing the mapping table between Hugo symbol, UniProt ID, and Pfam ACC. This dataset comes from the g3viz package and was obtained via this URL: https://github.com/morinlab/g3viz/tree/master/data\nhotspots_annotations Hotspot coordinates used in the feature annotation during matrix assembly of data for cFL classifier.\nmirage_metrics A data frame providing the data reported in the Supplemental Table of the MIRAGE study by Dreval et al, 2022\nmutation.table.df A data frame providing the linkage between Variant Classification, Mutation_Class, and Short_Name for the simple somatic mutations. reddy_genes A data frame of the genes reported as significantly mutated by the study of Reddy et al, 2017\nwright_genes_with_weights Wright genes with weight values."
  }
]